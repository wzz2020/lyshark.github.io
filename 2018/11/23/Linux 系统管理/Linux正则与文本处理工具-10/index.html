<!DOCTYPE html>













<html class="theme-next gemini" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">











<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.0.1',
    sidebar: {"position":"left","display":"hide","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: true,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"expandIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Linux 是一套免费使用和自由传播的类Unix操作系统,是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统.它能运行主要的UNIX工具软件、应用程序和网络协议.它支持32位和64位硬件.Linux继承了Unix以网络为核心的设计思想,是一个性能稳定的多用户网络操作系统. 正则表达式 (Regular Expression, RE, 或称为常规表达式)是通过一些特殊字符">
<meta name="keywords" content="Linux 系统管理">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux正则与文本处理工具(10)">
<meta property="og:url" content="https://www.mkdirs.com/2018/11/23/Linux 系统管理/Linux正则与文本处理工具-10/index.html">
<meta property="og:site_name" content="我的个人博客">
<meta property="og:description" content="Linux 是一套免费使用和自由传播的类Unix操作系统,是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统.它能运行主要的UNIX工具软件、应用程序和网络协议.它支持32位和64位硬件.Linux继承了Unix以网络为核心的设计思想,是一个性能稳定的多用户网络操作系统. 正则表达式 (Regular Expression, RE, 或称为常规表达式)是通过一些特殊字符">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://www.mkdirs.com/picture/20180925090607.jpg">
<meta property="og:image" content="https://www.mkdirs.com/picture/20180925090609.jpg">
<meta property="og:image" content="https://www.mkdirs.com/picture/20181123145818.jpg">
<meta property="og:image" content="https://www.mkdirs.com/picture/20181123145834.jpg">
<meta property="og:image" content="https://www.mkdirs.com/picture/20180925195717.jpg">
<meta property="og:updated_time" content="2019-04-16T12:34:22.341Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux正则与文本处理工具(10)">
<meta name="twitter:description" content="Linux 是一套免费使用和自由传播的类Unix操作系统,是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统.它能运行主要的UNIX工具软件、应用程序和网络协议.它支持32位和64位硬件.Linux继承了Unix以网络为核心的设计思想,是一个性能稳定的多用户网络操作系统. 正则表达式 (Regular Expression, RE, 或称为常规表达式)是通过一些特殊字符">
<meta name="twitter:image" content="https://www.mkdirs.com/picture/20180925090607.jpg">



  <link rel="alternate" href="/atom.xml" title="我的个人博客" type="application/atom+xml">




  <link rel="canonical" href="https://www.mkdirs.com/2018/11/23/Linux 系统管理/Linux正则与文本处理工具-10/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Linux正则与文本处理工具(10) | 我的个人博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">我的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.mkdirs.com/2018/11/23/Linux 系统管理/Linux正则与文本处理工具-10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王瑞">
      <meta itemprop="description" content="记录点滴技术成长之路">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Linux正则与文本处理工具(10)

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-23 12:05:10" itemprop="dateCreated datePublished" datetime="2018-11-23T12:05:10+08:00">2018-11-23</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-16 20:34:22" itemprop="dateModified" datetime="2019-04-16T20:34:22+08:00">2019-04-16</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Linux-系统管理/" itemprop="url" rel="index"><span itemprop="name">Linux 系统管理</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    
    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Linux 是一套免费使用和自由传播的类Unix操作系统,是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统.它能运行主要的UNIX工具软件、应用程序和网络协议.它支持32位和64位硬件.Linux继承了Unix以网络为核心的设计思想,是一个性能稳定的多用户网络操作系统.</p>
<p>正则表达式 (Regular Expression, RE, 或称为常规表达式)是通过一些特殊字符的排列,用于『查找/替换/删除』一行或多行文字或字符串,简单的说,正则表达式就是用在字串的处理上面的一种『表示公式』,正则表达式并不是一个工具程序,而是一个对字符串处理的标准依据,如果您想要以正则表达式的方式处理字串,就得要使用支持正则表达式的工具程序才行,这类的工具程序很多,例如 vi,vim,sed,awk,gawk,egrep等.</p>
<p>正则表达式,对于系统管理员来说是非常重要的,因为系统会产生很多的信息,这些信息有的重要有的仅是警告,此时管理员可以通过正则表达式来过滤出相应的我们需要的字段,你最好掌握这门技术,会对将来的数据分析,主机管理起到很大的帮助.</p>
<a id="more"></a>
<p><br></p>
<h2 id="基础正则表达式"><a href="#基础正则表达式" class="headerlink" title="基础正则表达式"></a>基础正则表达式</h2><p>在上一章说过正则表达式和通配符的区别,(正则表达式用来在文件中匹配符合条件的字符串,而通配符则是用来匹配符合条件的文件名)吗? 其实这种区别只在Shell当中适用,因为用来在文件当中搜索字符串的命令,如 grep、awk、sed 等命令可以支持正则表达式,而在系统当中搜索文件的命令,如 ls、find、cp 这些命令不支持正则表达式,所以只能使用shell自己的通配符来进行匹配了.</p>
<p>首先我们先来学习一下基础的正则表达式吧,下面是我们常用的正则语法,我会给每一个语法,举一个小例子,下面我们开始学习吧.</p>
<p><img src="/picture/20180925090607.jpg" alt="blockchain"></p>
<p><strong>实例1：</strong> <code>使用 *</code> 实现匹配前一个字符出现0次或任意多次(本例中,则是匹配g字符出现0次或任意多次)<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls</span></span><br><span class="line">wang  wangg  wanggg</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># ls | grep "wang*"</span></span><br><span class="line">wang</span><br><span class="line">wangg</span><br><span class="line">wanggg</span><br><span class="line">[root@localhost ~]<span class="comment"># ls | grep "wan*g*"</span></span><br><span class="line">wang</span><br><span class="line">wangg</span><br><span class="line">wanggg</span><br></pre></td></tr></table></figure></p>
<p><strong>实例2：</strong> <code>使用 .</code> 实现匹配除换行符以外的任意一个字符,(只匹配一个字符),一般我们把它叫做贪婪匹配<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls</span></span><br><span class="line">wang  wangg  wanggg wangr</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># ls | grep "wang"</span></span><br><span class="line">wang</span><br><span class="line">[root@localhost ~]<span class="comment"># ls | grep "wang."</span></span><br><span class="line">wangg</span><br><span class="line">wangr</span><br><span class="line">[root@localhost ~]<span class="comment"># ls | grep "wang.."</span></span><br><span class="line">wanggg</span><br></pre></td></tr></table></figure></p>
<p><strong>实例3：</strong> <code>使用 ^</code> 实现匹配行首是指定字符的行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls</span></span><br><span class="line">alert  lyshark  tcpl  wakaka  wang  wangg  wanggg  woxin</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># ls | grep "^ly"</span></span><br><span class="line">lyshark</span><br><span class="line">[root@localhost ~]<span class="comment"># ls | grep "^wa"</span></span><br><span class="line">wakaka</span><br><span class="line">wang</span><br><span class="line">wangg</span><br><span class="line">wanggg</span><br><span class="line">[root@localhost ~]<span class="comment"># ls | grep "^a"</span></span><br><span class="line">alert</span><br></pre></td></tr></table></figure></p>
<p><strong>实例4：</strong> <code>使用 $</code> 实现匹配行尾是指定字符的行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls</span></span><br><span class="line">alert  lyshark  tcpl  wakaka  wang  wangg  wanggg  woxin</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># ls | grep "a$"</span></span><br><span class="line">wakaka</span><br><span class="line">[root@localhost ~]<span class="comment"># ls | grep "ark$"</span></span><br><span class="line">lyshark</span><br><span class="line">[root@localhost ~]<span class="comment"># ls | grep "^w" | grep "n$"     #匹配开头是w结尾是n的</span></span><br><span class="line">woxin</span><br></pre></td></tr></table></figure></p>
<p><strong>实例5：</strong> <code>使用 []</code> 实现匹配中括号内任意一个字符,(只匹配其中一个)<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls</span></span><br><span class="line">ale1t  ale2t  ale3t  aleat  alebt  alert</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># ls | grep "ale[a-z]t"</span></span><br><span class="line">aleat</span><br><span class="line">alebt</span><br><span class="line">alert</span><br><span class="line">[root@localhost ~]<span class="comment"># ls | grep "ale[0-9]t"</span></span><br><span class="line">ale1t</span><br><span class="line">ale2t</span><br><span class="line">ale3t</span><br><span class="line">[root@localhost ~]<span class="comment"># ls | grep "ale[ab]t"</span></span><br><span class="line">aleat</span><br><span class="line">alebt</span><br></pre></td></tr></table></figure></p>
<p><strong>实例6：</strong> <code>使用 [^]</code> 实现匹配除了中括号字符以外的任意一个字符(^取反的意思)<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls</span></span><br><span class="line">ale1t  ale2t  ale3t  aleat  aleAt  aleBB  alebt  aleCT  aleEt  alert</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># ls | grep "ale[^0-9]t"</span></span><br><span class="line">aleat</span><br><span class="line">aleAt</span><br><span class="line">alebt</span><br><span class="line">aleEt</span><br><span class="line">alert</span><br><span class="line">[root@localhost ~]<span class="comment"># ls | grep "ale[^A-Z]t"</span></span><br><span class="line">ale1t</span><br><span class="line">ale2t</span><br><span class="line">ale3t</span><br><span class="line">aleat</span><br><span class="line">alebt</span><br><span class="line">alert</span><br><span class="line">[root@localhost ~]<span class="comment"># ls | grep "ale[^AE]t"</span></span><br><span class="line">ale1t</span><br><span class="line">ale2t</span><br><span class="line">ale3t</span><br><span class="line">aleat</span><br><span class="line">alebt</span><br><span class="line">alert</span><br></pre></td></tr></table></figure></p>
<p><strong>实例7：</strong> <code>使用 ^[^]</code> 实现匹配行首是与不是指定字符的行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls</span></span><br><span class="line">ale1t  ale2t lyshark  tcpl  wakaka  wang  wangg  wanggg  woxin</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># ls | grep ^[a]        #匹配行首是a开头的</span></span><br><span class="line">ale1t</span><br><span class="line">ale2t</span><br><span class="line">[root@localhost ~]<span class="comment"># ls | grep ^[^a]       #匹配行首不是a开头的</span></span><br><span class="line">lyshark</span><br><span class="line">tcpl</span><br><span class="line">wakaka</span><br><span class="line">wang</span><br><span class="line">wangg</span><br><span class="line">wanggg</span><br><span class="line">woxin</span><br></pre></td></tr></table></figure></p>
<p><strong>实例8：</strong> <code>使用 \{n}\</code> 实现匹配前面的字符恰好出现了n次的行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls</span></span><br><span class="line">12333  13466614578  13562653874  172.168.1.2  18264758942  192.168.1.1  45666  78999</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># ls | grep "123\&#123;3\&#125;"</span></span><br><span class="line">12333</span><br><span class="line">[root@localhost ~]<span class="comment"># ls | grep "[0-9][0-9][0-9]\&#123;3\&#125;"    #匹配前两个字符是0-9的,最后一个字符出现过3次的</span></span><br><span class="line">12333</span><br><span class="line">45666</span><br><span class="line">78999</span><br><span class="line">[root@localhost ~]<span class="comment"># ls | grep "[1][3-8][0-9]\&#123;9\&#125;"       #匹配手机号规则</span></span><br><span class="line">13466614578</span><br><span class="line">13562653874</span><br><span class="line">18264758942</span><br></pre></td></tr></table></figure></p>
<p><strong>实例9：</strong> <code>\{n,}\</code> 实现匹配前面的字符的出现,不小于n次的行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls</span></span><br><span class="line">12333  123333  1233333</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># ls | grep "123\&#123;3,\&#125;"               #前一个字符3的出现不小于3次</span></span><br><span class="line">12333</span><br><span class="line">123333</span><br><span class="line">1233333</span><br><span class="line">[root@localhost ~]<span class="comment"># ls | grep "123\&#123;4,\&#125;"               #前一个字符3的出现不小于4次</span></span><br><span class="line">123333</span><br><span class="line">1233333</span><br></pre></td></tr></table></figure></p>
<p><strong>实例10：</strong> <code>\{n,m}\</code> 实现匹配前面的字符出现,不小于n次,最多出现m次的行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls</span></span><br><span class="line">123  1233  12333  123333  1233333  12333333  123333333  1233333333  12333333333</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># ls |grep "123\&#123;3,5\&#125;"              #前一个字符3最少出现3次,最多不大于5次</span></span><br><span class="line">12333</span><br><span class="line">123333</span><br><span class="line">1233333</span><br></pre></td></tr></table></figure></p>
<p><strong>总结：匹配一个合法IP地址</strong><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls</span></span><br><span class="line">10.10.10.22  127.9.0.8    172.168.1.2  192.168.1.1  192.168.1.3      255.255.255.255</span><br><span class="line">127.0.0.1    172.168.1.1  172.168.1.3  192.168.1.2  192.199.256.256  256.256.256.256</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># ls | egrep "^(([1-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.)&#123;3&#125;([0-9]|[1-9][0-9]|1[0-9][0-9]|</span></span><br><span class="line">2[0-4][0-9]|25[0-4])$<span class="string">"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">10.10.10.22</span></span><br><span class="line"><span class="string">172.168.1.1</span></span><br><span class="line"><span class="string">172.168.1.2</span></span><br><span class="line"><span class="string">172.168.1.3</span></span><br><span class="line"><span class="string">192.168.1.1</span></span><br><span class="line"><span class="string">192.168.1.2</span></span><br><span class="line"><span class="string">192.168.1.3</span></span><br></pre></td></tr></table></figure></p>
<p><strong>总结：匹配一个合法邮箱地址</strong><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls</span></span><br><span class="line">1181506874@qq.com  lysharks@163.cn  lysharks@163.com  wangrui@126.com  wangrui@129.cc</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># ls | egrep "^[0-9a-zA-Z][0-9a-zA-Z_]&#123;1,16&#125;[0-9a-zA-Z]\@[0-9a-zA-Z-]*([0-9a-zA-Z])?\.(com|com.cn|net|</span></span><br><span class="line">org|cn)$<span class="string">"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1181506874@qq.com</span></span><br><span class="line"><span class="string">lysharks@163.cn</span></span><br><span class="line"><span class="string">lysharks@163.com</span></span><br><span class="line"><span class="string">wangrui@126.com</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="扩展正则表达式"><a href="#扩展正则表达式" class="headerlink" title="扩展正则表达式"></a>扩展正则表达式</h2><p>事实上,一般用户只要了解基础型的正则语句就已经相当足够了,不过,在某些时候,为了简化命令的长度,还是需要扩展正则的支持的,打个比方,我们可以使用 <code>cat xxx.log | grep -v &#39;^$&#39; |grep -v &#39;^#&#39;</code> 来实现过滤文本中的注释行,和空白行,但是这不够精简,它的执行还是会用到两次的过滤,如果使用扩展正则表达式,我们可以这样写,<code>cat xxx.log |egrep -v &#39;^$|^#&#39;</code> 这样一个命令就可实现上面的效果啦,此处我们需要说明的是,grep -E 和egrep效果是相同的,使用哪一个都一个样.</p>
<p>熟悉了基础正规表达式之后,再来看这个扩展正则表达式,是不是很轻松啊,亲,下面我们就来分别说明这几个符号的使用规则吧.</p>
<p><img src="/picture/20180925090609.jpg" alt="blockchain"></p>
<p><strong>实例1：</strong> <code>+</code> 实现匹配前一个字符出现1次或任意多次<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls</span></span><br><span class="line">gogle  google  gooogle  gooogooogle  goooogle  gooooogle  goooooogle</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># ls | grep -E "go+gle"</span></span><br><span class="line">gogle</span><br><span class="line">google</span><br><span class="line">gooogle</span><br><span class="line">goooogle</span><br><span class="line">gooooogle</span><br><span class="line">goooooogle</span><br></pre></td></tr></table></figure></p>
<p><strong>实例2：</strong> <code>?</code> 实现匹配前一个字符出现0次,或1次<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls</span></span><br><span class="line">gogle  google  gooogle  gooogooogle  goooogle  gooooogle  goooooogle</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># ls | grep -E "go?gle"</span></span><br><span class="line">gogle</span><br><span class="line">[root@localhost ~]<span class="comment"># ls | grep -E "goo?gle"</span></span><br><span class="line">gogle</span><br><span class="line">google</span><br></pre></td></tr></table></figure></p>
<p><strong>实例3：</strong> <code>|</code> 实现匹配两个或多个分支选择<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls</span></span><br><span class="line">alert  lyshark  rui  wang</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># ls | grep -E "alert|lyshark"</span></span><br><span class="line">alert</span><br><span class="line">lyshark</span><br><span class="line">[root@localhost ~]<span class="comment"># ls | grep -E "wang|rui|alert"</span></span><br><span class="line">alert</span><br><span class="line">rui</span><br><span class="line">wang</span><br></pre></td></tr></table></figure></p>
<p><strong>实例4：</strong> <code>()</code> 实现将字符作为一个整体匹配,即模式单元<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls</span></span><br><span class="line">dog  dogdog  dogdogdog  hello_lyshark  hello_world</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># ls | grep -E "(dog)+"</span></span><br><span class="line">dog</span><br><span class="line">dogdog</span><br><span class="line">dogdogdog</span><br><span class="line">[root@localhost ~]<span class="comment"># ls | grep -E "hello_(world|lyshark)"</span></span><br><span class="line">hello_lyshark</span><br><span class="line">hello_world</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="Grep-行处理工具"><a href="#Grep-行处理工具" class="headerlink" title="Grep 行处理工具"></a>Grep 行处理工具</h2><p>grep (global search regular expression(RE) and print out the line 全面搜索正则表达式并把行打印出来)是一种强大的文本搜索工具,它能使用正则表达式搜索文本,并把匹配的行打印出来,好了废话不多说,先看命令格式.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># grep --help</span></span><br><span class="line"></span><br><span class="line">命令语法：[ grep [选项] [过滤菜单] 文件名 ]</span><br><span class="line"></span><br><span class="line">        -a              <span class="comment">#将二进制数据一同列出</span></span><br><span class="line">        -c              <span class="comment">#计算找到查找字符串的次数</span></span><br><span class="line">        -i              <span class="comment">#忽略大小写差异</span></span><br><span class="line">        -n              <span class="comment">#顺便标号显示</span></span><br><span class="line">        -v              <span class="comment">#反选参数</span></span><br><span class="line">        -q              <span class="comment">#不显示任何提示信息,安静模式</span></span><br><span class="line">        -E              <span class="comment">#使用扩展正则,egrep</span></span><br><span class="line">        -A              <span class="comment">#匹配指定字符的后n个字符</span></span><br><span class="line">        -B              <span class="comment">#匹配指定字符的前n个字符</span></span><br><span class="line">        -C              <span class="comment">#匹配指定字符的前n个和后n个字符</span></span><br></pre></td></tr></table></figure>
<p><strong>实例1：</strong> 使用 <code>grep -n</code> 参数过滤数据时,一同标号<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat /etc/passwd | grep -n "root"</span></span><br><span class="line"></span><br><span class="line">1:root:x:0:0:root:/root:/bin/bash</span><br><span class="line">10:operator:x:11:0:operator:/root:/sbin/nologin</span><br></pre></td></tr></table></figure></p>
<p><strong>实例2：</strong> 使用 <code>grep -v</code> 反选打印,行中不包括/bin/bash的行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat /etc/passwd | grep -vn "/bin/bash"</span></span><br><span class="line"></span><br><span class="line">2:bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">3:daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">4:adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">5:lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">6:sync:x:5:0:sync:/sbin:/bin/sync</span><br><span class="line">7:shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</span><br><span class="line">8:halt:x:7:0:halt:/sbin:/sbin/halt</span><br><span class="line">....省略....</span><br></pre></td></tr></table></figure></p>
<p><strong>实例3：</strong> 使用 <code>grep -i</code> 过滤出不论大小写的lyshark单词的行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line">LyShark</span><br><span class="line">lyshark</span><br><span class="line">admin</span><br><span class="line">Admin</span><br><span class="line">ADMIN</span><br><span class="line">Good</span><br><span class="line">GOOD</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log | grep -ni "lyshark"</span></span><br><span class="line">1:LyShark</span><br><span class="line">2:lyshark</span><br></pre></td></tr></table></figure></p>
<p><strong>实例4：</strong> 使用正则,过滤出开头是 <code>^L</code> 的行的内容<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line">LyShark</span><br><span class="line">lyshark</span><br><span class="line">admin</span><br><span class="line">Admin</span><br><span class="line">ADMIN</span><br><span class="line">Good</span><br><span class="line">GOOD</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log | grep -n "^L"</span></span><br><span class="line">1:LyShark</span><br></pre></td></tr></table></figure></p>
<p><strong>实例5：</strong> 使用正则,过滤出开头不是 <code>^L</code>的行的内容<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line">LyShark</span><br><span class="line">lyshark</span><br><span class="line">admin</span><br><span class="line">Admin</span><br><span class="line">ADMIN</span><br><span class="line">Good</span><br><span class="line">GOOD</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log | grep -n "[^L]yshark"</span></span><br><span class="line">2:lyshark</span><br></pre></td></tr></table></figure></p>
<p><strong>实例6：</strong> 使用正则,过滤出开头是小写字母的行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line">LyShark</span><br><span class="line">lyshark</span><br><span class="line">admin</span><br><span class="line">Admin</span><br><span class="line">ADMIN</span><br><span class="line">Good</span><br><span class="line">GOOD</span><br><span class="line">123123</span><br><span class="line">1233</span><br><span class="line">66431</span><br><span class="line">124adb</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log | grep -n "^[a-z]"</span></span><br><span class="line">2:lyshark</span><br><span class="line">3:admin</span><br></pre></td></tr></table></figure></p>
<p><strong>实例7：</strong> 使用正则,过滤出开头不是,a-z或A-Z的行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line">LyShark</span><br><span class="line">lyshark</span><br><span class="line">admin</span><br><span class="line">Admin</span><br><span class="line">ADMIN</span><br><span class="line">Good</span><br><span class="line">GOOD</span><br><span class="line">123123</span><br><span class="line">1233</span><br><span class="line">66431</span><br><span class="line">124adb</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log | grep -n "^[^a-zA-Z]"</span></span><br><span class="line">8:123123</span><br><span class="line">9:1233</span><br><span class="line">10:66431</span><br><span class="line">11:124adb</span><br></pre></td></tr></table></figure></p>
<p><strong>实例8：</strong> 使用正则,找出结尾是小数点的哪一行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line">LyShark</span><br><span class="line">lyshark</span><br><span class="line">admin</span><br><span class="line">Admin</span><br><span class="line">ADMIN</span><br><span class="line">Good</span><br><span class="line">123123</span><br><span class="line">1233.</span><br><span class="line">66431.</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log |grep -n "\.$"</span></span><br><span class="line">8:1233.</span><br><span class="line">9:66431.</span><br></pre></td></tr></table></figure></p>
<p><strong>实例9：</strong> 使用正则,过滤掉开头是#号的,和开头是空行的行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line"><span class="comment">#LyShark</span></span><br><span class="line"><span class="comment">#lyshark</span></span><br><span class="line"><span class="comment">#admin</span></span><br><span class="line"><span class="comment">#Admin</span></span><br><span class="line"></span><br><span class="line">ADMIN</span><br><span class="line">Good</span><br><span class="line"></span><br><span class="line">123123</span><br><span class="line"></span><br><span class="line">1233.</span><br><span class="line">66431.</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log | grep -v "^#" | grep -v "^$"</span></span><br><span class="line">ADMIN</span><br><span class="line">Good</span><br><span class="line">123123</span><br><span class="line">1233.</span><br><span class="line">66431.</span><br></pre></td></tr></table></figure></p>
<p><strong>实例10：</strong> 使用正则,过滤出前一个字符o刚好出现两次的行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line"><span class="comment">#LyShark</span></span><br><span class="line"><span class="comment">#lyshark</span></span><br><span class="line"><span class="comment">#admin</span></span><br><span class="line"><span class="comment">#Admin</span></span><br><span class="line"></span><br><span class="line">ADMIN</span><br><span class="line">Good</span><br><span class="line">123123</span><br><span class="line">1233.</span><br><span class="line">66431.</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log |grep -n "o\&#123;2\&#125;"</span></span><br><span class="line">7:Good</span><br></pre></td></tr></table></figure></p>
<p><strong>实例11：</strong> 使用正则,匹配开头是0-9且结尾是点的行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line"><span class="comment">#LyShark</span></span><br><span class="line"><span class="comment">#lyshark</span></span><br><span class="line"><span class="comment">#admin</span></span><br><span class="line"><span class="comment">#Admin</span></span><br><span class="line"></span><br><span class="line">ADMIN</span><br><span class="line">Good</span><br><span class="line">123123</span><br><span class="line">1233.</span><br><span class="line">66431.</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log |grep -n -E "^[0-9]+\."</span></span><br><span class="line">9:1233.</span><br><span class="line">10:66431.</span><br></pre></td></tr></table></figure></p>
<p><strong>实例12：</strong> 使用正则,匹配指定字符的后2个字符,或前2个字符<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line">lyshark</span><br><span class="line">LySHARK</span><br><span class="line">wang</span><br><span class="line">rui</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">alert</span><br><span class="line">123123</span><br><span class="line">45678</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log |grep -n -A 2 "hello"</span></span><br><span class="line">5:hello</span><br><span class="line">6-world</span><br><span class="line">7-alert</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log |grep -n -B 2 "hello"</span></span><br><span class="line">3-wang</span><br><span class="line">4-rui</span><br><span class="line">5:hello</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="Cut-列提取工具"><a href="#Cut-列提取工具" class="headerlink" title="Cut 列提取工具"></a>Cut 列提取工具</h2><p>cut命令用来显示行中的指定部分,删除文件中指定字段,cut经常用来显示文件的内容,类似于type命令.该命令有两项功能,其一是用来显示文件的内容,它依次读取由参数file所指明的文件,将它们的内容输出到标准输出上.其二是连接两个或多个文件,如cut fl f2 &gt; f3 将把文件fl和f2的内容合并,然后通过输出重定向符”&gt;” 的作用,将它们放入文件f3中.</p>
<p>首先我们来看一下它的格式吧,如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cut --help</span></span><br><span class="line"></span><br><span class="line">命令语法：[ cut [选项] [列号] 文件名 ]</span><br><span class="line"></span><br><span class="line">        -f              <span class="comment">#-f 列号：指定提取第几列</span></span><br><span class="line">        -d              <span class="comment">#-d 分隔符：按照指定分隔符进行分割</span></span><br><span class="line">        -c              <span class="comment">#-c 字符范围：不依赖分割符来分割,而是通过字符范围进行字段提取</span></span><br><span class="line">        -m              <span class="comment">#表示从第一个字符提取到第m个</span></span><br><span class="line">        -b              <span class="comment">#仅显示行中指定直接范围的内容</span></span><br><span class="line">        -n              <span class="comment">#与"-b"选项连用,不分割多字节字符</span></span><br><span class="line">        n-              <span class="comment">#表示从第n个字符开始提取到结尾</span></span><br><span class="line">        n-m             <span class="comment">#表示从第n提取到第m个字符</span></span><br><span class="line"></span><br><span class="line">        --complement    <span class="comment">#补齐被选择的字节,字符或字段</span></span><br><span class="line">        --out-delimiter=&lt;字段分隔符&gt; <span class="comment">#指定输出内容是的字段分割符</span></span><br></pre></td></tr></table></figure></p>
<p>手动创建一个文本,添加内容列之间用tab分隔,用来测试后续内容<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line"></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">1       WR      22      m       100</span><br><span class="line">2       LC      26      m       90</span><br><span class="line">3       LY      23      m       88</span><br></pre></td></tr></table></figure></p>
<p><strong>实例1：</strong> 通过使用 <code>-f</code> 选项指定过滤的列,并显示到屏幕<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line"></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">1       WR      22      m       100</span><br><span class="line">2       LC      26      m       90</span><br><span class="line">3       LY      23      m       88</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cut -f 2 lyshark.log</span></span><br><span class="line">NAME</span><br><span class="line">WR</span><br><span class="line">LC</span><br><span class="line">LY</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cut -f 2,5 lyshark.log</span></span><br><span class="line">NAME    Mark</span><br><span class="line">WR      100</span><br><span class="line">LC      90</span><br><span class="line">LY      88</span><br></pre></td></tr></table></figure></p>
<p><strong>实例2：</strong> 通过使用 <code>--complement</code> 选项提取指定字段之外的列,(打印除了第2列之外的列)<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line"></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">1       WR      22      m       100</span><br><span class="line">2       LC      26      m       90</span><br><span class="line">3       LY      23      m       88</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cut -f 2 --complement lyshark.log</span></span><br><span class="line"></span><br><span class="line">ID      AGE     Gender  Mark</span><br><span class="line">1       22      m       100</span><br><span class="line">2       26      m       90</span><br><span class="line">3       23      m       88</span><br></pre></td></tr></table></figure></p>
<p><strong>实例3：</strong> 通过使用 <code>-c</code> 选项过滤/etc/passwd,并打印第1个到第3个字符<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cut -c 1-3 /etc/passwd</span></span><br><span class="line">roo</span><br><span class="line">bin</span><br><span class="line">dae</span><br><span class="line">adm</span><br><span class="line">lp:</span><br><span class="line">syn</span><br><span class="line">....省略....</span><br></pre></td></tr></table></figure></p>
<p><strong>实例4：</strong> 通过使用 <code>-c -2</code> 选项过滤/etc/passwd,并打印前2个字符<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cut -c -2 /etc/passwd</span></span><br><span class="line">ro</span><br><span class="line">bi</span><br><span class="line">da</span><br><span class="line">ad</span><br><span class="line">lp</span><br><span class="line">....省略....</span><br></pre></td></tr></table></figure></p>
<p><strong>实例5：</strong> 通过使用 <code>-c 5-</code> 选项过滤/etc/passwd,打印从第5个字符开始到结尾<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cut -c 5- /etc/passwd</span></span><br><span class="line">:x:0:0:root:/root:/bin/bash</span><br><span class="line">x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">on:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">....省略....</span><br></pre></td></tr></table></figure></p>
<p><strong>实例6：</strong> 通过使用 <code>-d</code> 指定分隔符 <code>-f</code> 指定打印第个字段,以下我们分别截取第1和第7个字段<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cut -d ":" -f 1,7 /etc/passwd</span></span><br><span class="line">root:/bin/bash</span><br><span class="line">bin:/sbin/nologin</span><br><span class="line">daemon:/sbin/nologin</span><br><span class="line">adm:/sbin/nologin</span><br><span class="line">lp:/sbin/nologin</span><br><span class="line">sync:/bin/sync</span><br><span class="line">....省略....</span><br></pre></td></tr></table></figure></p>
<p><strong>实例7：</strong> 通过使用 <code>-c -3</code> 指定截取前3个字符,还可以通过 <code>-c 3</code> 截取第3个字符<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cut -c -3 /etc/passwd</span></span><br><span class="line">roo</span><br><span class="line">bin</span><br><span class="line">dae</span><br><span class="line">adm</span><br><span class="line">lp:</span><br><span class="line">....省略....</span><br><span class="line">[root@localhost ~]<span class="comment"># cut -c 3 /etc/passwd</span></span><br><span class="line">o</span><br><span class="line">n</span><br><span class="line">e</span><br><span class="line">m</span><br><span class="line">:</span><br><span class="line">n</span><br><span class="line">....省略....</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="Sed-流编辑器"><a href="#Sed-流编辑器" class="headerlink" title="Sed 流编辑器"></a>Sed 流编辑器</h2><p>sed是一种流编辑器,它是文本处理中非常中的工具,能够完美的配合正则表达式使用,功能不同凡响.处理时,把当前处理的行存储在临时缓冲区中,称为 “模式空间” (pattern space),接着用sed命令处理缓冲区中的内容,处理完成后,把缓冲区的内容送往屏幕,接着处理下一行,这样不断重复,直到文件末尾.文件内容并没有改变,除非你使用重定向存储输出.Sed主要用来自动编辑一个或多个文件,简化对文件的反复操作,编写转换程序等.</p>
<p>sed主要是来进行数据选取,替换,删除,新增的命令,二话不说先看一下它的参数吧.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># sed --help</span></span><br><span class="line"></span><br><span class="line">命令语法：[ sed [选项] [范围] [动作] 文件名 ]</span><br><span class="line"></span><br><span class="line">        -n              <span class="comment">#把经过sed命令处理的行输出到屏幕</span></span><br><span class="line">        -e              <span class="comment">#允许对输入数据应用多条sed命令编辑</span></span><br><span class="line">        -f              <span class="comment">#从sed脚本中读入sed操作,和awk命令的-f类似</span></span><br><span class="line">        -r              <span class="comment">#在sed中支持扩展正则表达式</span></span><br><span class="line">        -i              <span class="comment">#用sed的修改结果,写到文件</span></span><br><span class="line"></span><br><span class="line">命令动作：</span><br><span class="line"></span><br><span class="line">        p               <span class="comment">#打印,输出指定的行</span></span><br><span class="line">        a               <span class="comment">#追加,在当前行后添加一行或多行</span></span><br><span class="line">        i               <span class="comment">#插入,在当前行前插入一行或多行</span></span><br><span class="line">        c               <span class="comment">#整行替换,用c后面的字符串替换原数据行</span></span><br><span class="line">        d               <span class="comment">#删除,删除指定的行</span></span><br><span class="line">        s               <span class="comment">#字串替换,格式："行范围s/旧字串/新字串/g"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#对sed命令我们要知道的是,它所有的修改都不会直接修改文件的内容,而是在内存中进行处理然后打印到屏幕上</span></span><br><span class="line"><span class="comment">#如果想要写入文件,请使用 sed -i 选项才会保存到文本中.</span></span><br></pre></td></tr></table></figure></p>
<p>在进行实验之前,首先创建一个文件,来做测试用<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line"></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">1       WR      22      m       100</span><br><span class="line">2       LC      26      m       90</span><br><span class="line">3       LY      23      m       88</span><br><span class="line">4       XDL     40      b       100</span><br></pre></td></tr></table></figure></p>
<p><strong>实例1：</strong> 使用 <code>sed &#39;2p&#39;</code> 重复打印第二行数据<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">1       WR      22      m       100</span><br><span class="line">2       LC      26      m       90</span><br><span class="line">3       LY      23      m       88</span><br><span class="line">4       XDL     40      b       100</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># sed '2p' lyshark.log</span></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">1       WR      22      m       100</span><br><span class="line">1       WR      22      m       100    ←本行是2p打印的</span><br><span class="line">2       LC      26      m       90</span><br><span class="line">3       LY      23      m       88</span><br><span class="line">4       XDL     40      b       100</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># sed '3p' lyshark.log</span></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">1       WR      22      m       100</span><br><span class="line">2       LC      26      m       90</span><br><span class="line">2       LC      26      m       90     ←本行是2p打印的</span><br><span class="line">3       LY      23      m       88</span><br><span class="line">4       XDL     40      b       100</span><br></pre></td></tr></table></figure></p>
<p><strong>实例2：</strong> 使用 <code>sed -n</code> 限定,只选取指定的行进行显示<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">1       WR      22      m       100</span><br><span class="line">2       LC      26      m       90</span><br><span class="line">3       LY      23      m       88</span><br><span class="line">4       XDL     40      b       100</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># sed -n '2p' lyshark.log  ←只打印第2行数据</span></span><br><span class="line">1       WR      22      m       100</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># sed -n '1p' lyshark.log  ←只打印第1行数据</span></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br></pre></td></tr></table></figure></p>
<p><strong>实例3：</strong> 使用 <code>sed &#39;2,4d&#39;</code>  删除掉文件2-4行,并显示到屏幕,(原文件内容并没有被修改)<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">1       WR      22      m       100</span><br><span class="line">2       LC      26      m       90</span><br><span class="line">3       LY      23      m       88</span><br><span class="line">4       XDL     40      b       100</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># sed '2,4d' lyshark.log   ←删除2-4行的数据并打印</span></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">4       XDL     40      b       100</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># sed '1d' lyshark.log     ←删除第1行的数据</span></span><br><span class="line">1       WR      22      m       100</span><br><span class="line">2       LC      26      m       90</span><br><span class="line">3       LY      23      m       88</span><br><span class="line">4       XDL     40      b       100</span><br></pre></td></tr></table></figure></p>
<p><strong>实例4：</strong> 使用 <code>sed &#39;2[a|i]&#39;</code> 追加,或者插入数据指定数据<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">1       WR      22      m       100</span><br><span class="line">2       LC      26      m       90</span><br><span class="line">3       LY      23      m       88</span><br><span class="line">4       XDL     40      b       100</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># sed '2a hello lyshark' lyshark.log      ←在第2行后面追加数据</span></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">1       WR      22      m       100</span><br><span class="line">hello lyshark</span><br><span class="line">2       LC      26      m       90</span><br><span class="line">3       LY      23      m       88</span><br><span class="line">4       XDL     40      b       100</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># sed '2i hello lyshark' lyshark.log      ←在第2行前面插入数据</span></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">hello lyshark</span><br><span class="line">1       WR      22      m       100</span><br><span class="line">2       LC      26      m       90</span><br><span class="line">3       LY      23      m       88</span><br><span class="line">4       XDL     40      b       100</span><br></pre></td></tr></table></figure></p>
<p><strong>实例5：</strong> 使用 <code>\</code> 换行符,一次插入多行数据<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">1       WR      22      m       100</span><br><span class="line">2       LC      26      m       90</span><br><span class="line">3       LY      23      m       88</span><br><span class="line">4       XDL     40      b       100</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># sed '2a hello \    ←在第二行下面,插入一段话,用\隔开</span></span><br><span class="line">&gt; my name is lyshark \</span><br><span class="line">&gt; age 22 \</span><br><span class="line">&gt; boy <span class="string">' lyshark.log</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ID      NAME    AGE     Gender  Mark</span></span><br><span class="line"><span class="string">1       WR      22      m       100</span></span><br><span class="line"><span class="string">hello</span></span><br><span class="line"><span class="string">my name is lyshark</span></span><br><span class="line"><span class="string">age 22</span></span><br><span class="line"><span class="string">boy</span></span><br><span class="line"><span class="string">2       LC      26      m       90</span></span><br><span class="line"><span class="string">3       LY      23      m       88</span></span><br><span class="line"><span class="string">4       XDL     40      b       100</span></span><br></pre></td></tr></table></figure></p>
<p><strong>实例6：</strong> 使用 <code>sed &#39;c&#39;</code> 实现整行替换数据<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">1       WR      22      m       100</span><br><span class="line">2       LC      26      m       90</span><br><span class="line">3       LY      23      m       88</span><br><span class="line">4       XDL     40      b       100</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log | sed '5c 5    WRS    99    m    111'  ←整行替换第5行内容</span></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">1       WR      22      m       100</span><br><span class="line">2       LC      26      m       90</span><br><span class="line">3       LY      23      m       88</span><br><span class="line">5    WRS    99    m    111</span><br></pre></td></tr></table></figure></p>
<p><strong>实例7：</strong> 使用 <code>sed</code> 后面跟上 <code>-i</code> 选项,将第5行的修改,保存进文件,(-i选项是回写)<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">1       WR      22      m       100</span><br><span class="line">2       LC      26      m       90</span><br><span class="line">3       LY      23      m       88</span><br><span class="line">4       XDL     40      b       100</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># sed  -i '5c 5     WRS    99    m    111' lyshark.log</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">1       WR      22      m       100</span><br><span class="line">2       LC      26      m       90</span><br><span class="line">3       LY      23      m       88</span><br><span class="line">5       WRS    99    m    111               ←这里的数据已经写入成功</span><br></pre></td></tr></table></figure></p>
<p><strong>实例8：</strong> 字符串的替换 <code>sed &#39;s/旧文本/新文本/g&#39;</code> 进行整行替换<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">1       WR      22      m       100</span><br><span class="line">2       LC      26      m       90</span><br><span class="line">3       LY      23      m       88</span><br><span class="line">5       WRS     99      m       111</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># sed '2s/WR/LyShark/g' lyshark.log   ←将第2行的,WR替换成LyShark</span></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">1       LyShark 22      m       100</span><br><span class="line">2       LC      26      m       90</span><br><span class="line">3       LY      23      m       88</span><br><span class="line">5       WRS     99      m       111</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># sed '3s/LC/Admin/g' lyshark.log     ←将第3行的,LC替换成Admin</span></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">1       WR      22      m       100</span><br><span class="line">2       Admin   26      m       90</span><br><span class="line">3       LY      23      m       88</span><br><span class="line">5     WRS    99    m    111</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意：上方只是替换打印,并没有保存,如若想保存请加 -i 属性</span></span><br></pre></td></tr></table></figure></p>
<p><strong>实例9：</strong> 将第3行数据的开头添加#注释<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">1       WR      22      m       100</span><br><span class="line">2       LC      26      m       90</span><br><span class="line">3       LY      23      m       88</span><br><span class="line">5       WRS     99      m       111</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># sed '3s/^/#/g' lyshark.log</span></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">1       WR      22      m       100</span><br><span class="line"><span class="comment">#2      LC      26      m       90</span></span><br><span class="line">3       LY      23      m       88</span><br><span class="line">5       WRS     99      m       111</span><br></pre></td></tr></table></figure></p>
<p><strong>实例10：</strong> 将第4和第5行的内容替换成空<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">1       WR      22      m       100</span><br><span class="line">2       LC      26      m       90</span><br><span class="line">3       LY      23      m       88</span><br><span class="line">5       WRS     99      m       111</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># sed -e '4s/LY//g ; 5s/WRS//g' lyshark.log</span></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">1       WR      22      m       100</span><br><span class="line">2       LC      26      m       90</span><br><span class="line">3               23      m       88</span><br><span class="line">5               99      m       111</span><br><span class="line"></span><br><span class="line"><span class="comment">#sed 要进行多行操作时,只能通过 -e 写多条操作语句,用 ; 或回车分隔</span></span><br></pre></td></tr></table></figure></p>
<p><strong>过滤IP地址小实验</strong><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ifconfig</span></span><br><span class="line">ens32: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.1.10  netmask 255.255.255.0  broadcast 192.168.1.255</span><br><span class="line">        inet6 fe80::897c:d72d:cd95:b9ec  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:b1:b7:be  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 2344  bytes 156370 (152.7 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 454  bytes 50049 (48.8 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># ifconfig | grep "inet 192" |sed 's/^.*inet //g'</span></span><br><span class="line">192.168.1.10  netmask 255.255.255.0  broadcast 192.168.1.255</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># ifconfig |grep "inet 192" |sed 's/^.*inet //g' |sed 's/ netmask.*$//g'</span></span><br><span class="line">192.168.1.10</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="Printf-文本格式化"><a href="#Printf-文本格式化" class="headerlink" title="Printf 文本格式化"></a>Printf 文本格式化</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># printf --help</span></span><br><span class="line"></span><br><span class="line">输出类型：</span><br><span class="line">        %ns:            <span class="comment">#输出字符串,n是数字,指代输出几个字符</span></span><br><span class="line">        %ni:            <span class="comment">#输出证书,n是数字,指代输出几个数字</span></span><br><span class="line">        %m.nf:          <span class="comment">#输出浮点数,m和n是数字,指代输出整数位和小数位</span></span><br><span class="line"></span><br><span class="line">输出格式：</span><br><span class="line">        \a:             <span class="comment">#输出警告音</span></span><br><span class="line">        \b:             <span class="comment">#输出退格键,也就是Backspace键</span></span><br><span class="line">        \f:             <span class="comment">#清屏</span></span><br><span class="line">        \n:             <span class="comment">#换行符</span></span><br><span class="line">        \r:             <span class="comment">#回车,也就是Enter键</span></span><br><span class="line">        \t:             <span class="comment">#水平输出退格键,也就是Tab键</span></span><br><span class="line">        \v:             <span class="comment">#垂直输出退格键,也就是Tab键</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意：print 和 printf 的主要区别在有 printf 是标准的格式化输出,必须手动指定换行和tab.</span></span><br></pre></td></tr></table></figure>
<p>在进行实验之前,首先创建一个文件,来做测试用<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line"></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">1       WR      22      m       100</span><br><span class="line">2       LC      26      m       90</span><br><span class="line">3       LY      23      m       88</span><br><span class="line">4       XDL     40      b       100</span><br></pre></td></tr></table></figure></p>
<p><strong>实例1：</strong> 通过 <code>printf</code> 函数打印文本内容</p>
<p>printf命令,如果不指定输出格式,则会把所有输出内容连在一起输出,其实文本的输出本身就是这样的,cat等文本输出命令之所以可以按照格式漂亮的输出,那是因为cat命令已经设定了输出格式.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># printf '%s' $(cat lyshark.log)</span></span><br><span class="line"></span><br><span class="line">IDNAMEAGEGenderMark1WR22m1002LC26m903LY23m884XDL40b100</span><br></pre></td></tr></table></figure></p>
<p><strong>实例2：</strong> 通过 <code>printf</code> 格式化后输出一段文本<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># printf '%s\t %s\t %s\t %s\t %s\t \n' $(cat lyshark.log)</span></span><br><span class="line"></span><br><span class="line">ID       NAME    AGE     Gender  Mark</span><br><span class="line">1        WR      22      m       100</span><br><span class="line">2        LC      26      m       90</span><br><span class="line">3        LY      23      m       88</span><br><span class="line">4        XDL     40      b       100</span><br></pre></td></tr></table></figure></p>
<p><strong>实例3：</strong> 通过 <code>printf</code> 按照整数型和浮点型输出,则需要修改<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">1       WR      22      m       100</span><br><span class="line">2       LC      26      m       90</span><br><span class="line">3       LY      23      m       88</span><br><span class="line">4       XDL     40      b       100</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># printf '%i\t %s\t %8.2f\t %s\t %s\t \n' $(cat lyshark.log |grep -v ID)</span></span><br><span class="line">1        WR         22.00        m       100</span><br><span class="line">2        LC         26.00        m       90</span><br><span class="line">3        LY         23.00        m       88</span><br><span class="line">4        XDL        40.00        b       100</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="Awk-正则表达工具"><a href="#Awk-正则表达工具" class="headerlink" title="Awk 正则表达工具"></a>Awk 正则表达工具</h2><p>awk是一种编程语言,用于在linux/unix下对文本和数据进行处理,数据可以来自标准输入(stdin),一个或多个文件,或其它命令的输出.它支持用户自定义函数和动态正则表达式等先进功能,是linux/unix下的一个强大编程工具,它在命令行中使用,但更多是作为脚本来使用.awk有很多内建的功能,比如数组、函数等,这是它和C语言的相同之处,灵活性是awk最大的优势.</p>
<p>在开始看例子之前,老样子,你懂的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># awk --help</span></span><br><span class="line">Usage: awk [POSIX or GNU style options] -f progfile [--] file ...</span><br><span class="line">Usage: awk [POSIX or GNU style options] [--] <span class="string">'program'</span> file ...</span><br><span class="line"></span><br><span class="line">命令语法：[ awk <span class="string">'条件1&#123;动作1&#125; 条件2&#123;动作2&#125; ....'</span> 文件名 ]</span><br><span class="line"></span><br><span class="line">条件：一般使用关系表达式作为条件</span><br><span class="line">                x&gt;10    判断x变量是否大于10</span><br><span class="line">                x==y    判断变量x是否等于变量y</span><br><span class="line">                A ~ B   判断字符串A中是否包含能匹配B表达式的字符串</span><br><span class="line">                A!~ B   判断字符串A中是否不包含能匹配B表达式的字符串</span><br></pre></td></tr></table></figure>
<p>在进行实验之前,首先创建一个文件,来做测试用<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line"></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">1       WR      22      m       100</span><br><span class="line">2       LC      26      m       90</span><br><span class="line">3       LY      23      m       88</span><br><span class="line">4       XDL     40      b       100</span><br></pre></td></tr></table></figure></p>
<h3 id="◆awk常用例子◆"><a href="#◆awk常用例子◆" class="headerlink" title="◆awk常用例子◆"></a>◆awk常用例子◆</h3><p><strong>实例1：</strong> 使用awk格式化输出第二列和第三列的内容<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">1       WR      22      m       100</span><br><span class="line">2       LC      26      m       90</span><br><span class="line">3       LY      23      m       88</span><br><span class="line">4       XDL     40      b       100</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># awk '&#123; printf $2 "\t" $3 "\n" &#125;' lyshark.log</span></span><br><span class="line">NAME    AGE</span><br><span class="line">WR      22</span><br><span class="line">LC      26</span><br><span class="line">LY      23</span><br><span class="line">XDL     40</span><br></pre></td></tr></table></figure></p>
<p><strong>实例2：</strong> 通过awk命令截取Size和Used命令的显示列<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># df -h</span></span><br><span class="line">Filesystem               Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/centos-root  8.0G  1.2G  6.9G  15% /</span><br><span class="line">devtmpfs                  98M     0   98M   0% /dev</span><br><span class="line">tmpfs                    110M     0  110M   0% /dev/shm</span><br><span class="line">tmpfs                    110M  5.5M  104M   5% /run</span><br><span class="line">tmpfs                    110M     0  110M   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1               1014M  130M  885M  13% /boot</span><br><span class="line">tmpfs                     22M     0   22M   0% /run/user/0</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># df -h |awk '&#123; printf $2 "\t" $3 "\n" &#125;'</span></span><br><span class="line">Size    Used</span><br><span class="line">8.0G    1.2G</span><br><span class="line">98M     0</span><br><span class="line">110M    0</span><br><span class="line">110M    5.5M</span><br><span class="line">110M    0</span><br><span class="line">1014M   130M</span><br><span class="line">22M     0</span><br></pre></td></tr></table></figure></p>
<h3 id="◆begin-与-end◆"><a href="#◆begin-与-end◆" class="headerlink" title="◆begin 与 end◆"></a>◆begin 与 end◆</h3><p><img src="/picture/20181123145818.jpg" alt="blockchain"></p>
<p>BEGIN是awk的保留字,是一种特殊的条件类型.BEGIN的执行时机是 “在awk程序一开始时,尚未读取任何数据之前执行”,一旦BEGIN后的动作执行一次,当awk开始从文件中读入数据,BEGIN的条件就不再成立,所以BEGIN定义的动作只能被执行一次,例如：</p>
<p>下面的,整个动作定义了两个动作,先打印 “执行语句前,执行我” 然后输出过滤后的2和4列<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">1       WR      22      m       100</span><br><span class="line">2       LC      26      m       90</span><br><span class="line">3       LY      23      m       88</span><br><span class="line">4       XDL     40      b       100</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># awk 'BEGIN&#123; printf "执行语句前,执行我 \n" &#125;&#123; printf $2 "\t" $4 "\n" &#125;' lyshark.log</span></span><br><span class="line">执行语句前,执行我</span><br><span class="line">NAME    Gender</span><br><span class="line">WR      m</span><br><span class="line">LC      m</span><br><span class="line">LY      m</span><br><span class="line">XDL     b</span><br></pre></td></tr></table></figure></p>
<p>END也是awk保留字,不过刚好和BEGIN相反,END是在awk程序处理完所有数据,即将结束时执行.END后的动作只在程序结束时执行一次.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">1       WR      22      m       100</span><br><span class="line">2       LC      26      m       90</span><br><span class="line">3       LY      23      m       88</span><br><span class="line">4       XDL     40      b       100</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># awk 'END&#123; printf "执行语句结束后,执行我 \n" &#125;&#123; printf $2 "\t" $4 "\n" &#125;' lyshark.log</span></span><br><span class="line">NAME    Gender</span><br><span class="line">WR      m</span><br><span class="line">LC      m</span><br><span class="line">LY      m</span><br><span class="line">XDL     b</span><br><span class="line">执行语句结束后,执行我</span><br></pre></td></tr></table></figure></p>
<p>BEGIN与END连用,以下例子也就是实现了,开始前执行打印 “执行语句前,先执行我”,结束时执行打印 “执行语句后,在执行我”<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">1       WR      22      m       100</span><br><span class="line">2       LC      26      m       90</span><br><span class="line">3       LY      23      m       88</span><br><span class="line">4       XDL     40      b       100</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># awk 'BEGIN&#123; printf "执行语句前,先执行我 \n" &#125;END&#123; printf "执行语句后,在执行我 \n"&#125;&#123; printf $2 "\t"</span></span><br><span class="line"><span class="variable">$4</span> <span class="string">"\n"</span> &#125;<span class="string">' lyshark.log</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">执行语句前,先执行我</span></span><br><span class="line"><span class="string">NAME    Gender</span></span><br><span class="line"><span class="string">WR      m</span></span><br><span class="line"><span class="string">LC      m</span></span><br><span class="line"><span class="string">LY      m</span></span><br><span class="line"><span class="string">XDL     b</span></span><br><span class="line"><span class="string">执行语句后,在执行我</span></span><br></pre></td></tr></table></figure></p>
<h3 id="◆awk关系运算◆"><a href="#◆awk关系运算◆" class="headerlink" title="◆awk关系运算◆"></a>◆awk关系运算◆</h3><p><img src="/picture/20181123145834.jpg" alt="blockchain"></p>
<p>关系运算符：设定条件,符合执行不符合不执行,下面设定条件为AGE字段&gt;=25岁的列出<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">1       WR      22      m       100</span><br><span class="line">2       LC      26      m       90</span><br><span class="line">3       LY      23      m       88</span><br><span class="line">4       XDL     40      b       100</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log | grep -v ID | awk '$3 &gt;=25 &#123;print $1 "\t" $2&#125;'</span></span><br><span class="line">2       LC</span><br><span class="line">4       XDL</span><br></pre></td></tr></table></figure></p>
<h3 id="◆awk正则搜索◆"><a href="#◆awk正则搜索◆" class="headerlink" title="◆awk正则搜索◆"></a>◆awk正则搜索◆</h3><blockquote>
<p>awk是列提取命令,第一步的动作却是先读入第一行,整个执行步骤：</p>
<blockquote>
<p>⦁ 如果有BEGIN条件,则先执行BEGIN定义动作.<br>⦁ 如果没有BEGIN条件,则先读入第一行,把第一行的数据依次赋成$0 $1 $2 $3 …等变量,$0 代表整行数据,$1 则为第一个字段,依次类推.<br>⦁ 读入下一行,重复赋值变量,并打印数据.</p>
</blockquote>
</blockquote>
<p><strong>指定搜索：</strong> 正则搜索第2列NAME字段,包含XDL的行,并打印出AGE列对应的值<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">1       WR      22      m       100</span><br><span class="line">2       LC      26      m       90</span><br><span class="line">3       LY      23      m       88</span><br><span class="line">4       XDL     40      b       100</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># awk '$2 ~/XDL/ &#123;printf $3 "\n"&#125;' lyshark.log</span></span><br><span class="line">40</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># df -h</span></span><br><span class="line">Filesystem               Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/centos-root  8.0G  1.2G  6.9G  15% /</span><br><span class="line">devtmpfs                  98M     0   98M   0% /dev</span><br><span class="line">tmpfs                    110M     0  110M   0% /dev/shm</span><br><span class="line">tmpfs                    110M  5.5M  104M   5% /run</span><br><span class="line">tmpfs                    110M     0  110M   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1               1014M  130M  885M  13% /boot</span><br><span class="line">tmpfs                     22M     0   22M   0% /run/user/0</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># df -h | grep -v "Filesystem" | awk ' $1 ~/sda1/ &#123;print $2&#125;'</span></span><br><span class="line">1014M</span><br></pre></td></tr></table></figure></p>
<p><strong>全局搜索：</strong> 正则全局搜索包含WR的字段行,并打印本行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line">ID      NAME    AGE     Gender  Mark</span><br><span class="line">1       WR      22      m       100</span><br><span class="line">2       LC      26      m       90</span><br><span class="line">3       LY      23      m       88</span><br><span class="line">4       XDL     40      b       100</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log | awk '/WR/ &#123;printf $0 "\n"&#125;'</span></span><br><span class="line">1       WR      22      m       100</span><br></pre></td></tr></table></figure></p>
<p><strong>屏蔽显示：</strong> 查看 df 的真实分区的使用情况,不看光盘和虚拟磁盘<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># df -h</span></span><br><span class="line">Filesystem               Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/centos-root  8.0G  1.2G  6.9G  15% /</span><br><span class="line">devtmpfs                  98M     0   98M   0% /dev</span><br><span class="line">tmpfs                    110M     0  110M   0% /dev/shm</span><br><span class="line">tmpfs                    110M  5.5M  104M   5% /run</span><br><span class="line">tmpfs                    110M     0  110M   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1               1014M  130M  885M  13% /boot</span><br><span class="line">tmpfs                     22M     0   22M   0% /run/user/0</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># df -h | awk '/sda[0-9]/ &#123;printf $1 "\t" $5"\n"&#125;'</span></span><br><span class="line">/dev/sda1       13%</span><br></pre></td></tr></table></figure></p>
<h3 id="◆awk内置变量◆"><a href="#◆awk内置变量◆" class="headerlink" title="◆awk内置变量◆"></a>◆awk内置变量◆</h3><p><img src="/picture/20180925195717.jpg" alt="blockchain"></p>
<p><strong>实例1：</strong> 通过内置变量 <code>FS=&quot;:&quot;</code> 定义分隔符,打印/etc/passwd文件的第1列和第3列<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat /etc/passwd |grep "/bin/bash"</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cat /etc/passwd |grep "/bin/bash" | \</span></span><br><span class="line">&gt; awk <span class="string">'BEGIN &#123;FS=":"&#125; &#123;printf $1 "\t" $3 "\n"&#125;'</span></span><br><span class="line"></span><br><span class="line">root    0</span><br></pre></td></tr></table></figure></p>
<p><strong>实例2：</strong> 打印行内容的同时,打印出行号(NR变量),和字段数(NF变量)<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat /etc/passwd | grep "/bin/bash" | </span></span><br><span class="line">\ awk <span class="string">'BEGIN&#123;FS=":"&#125; &#123;print $1 "\t" $3 "\t" "行号: " NR "\t" "</span></span><br><span class="line"><span class="string">字段数: " NF&#125;'</span></span><br><span class="line"></span><br><span class="line">root    0       行号: 1 字段数: 7</span><br></pre></td></tr></table></figure></p>
<p><strong>实例3：</strong> 打印行内容,首先判断 <code>$1==sshd</code> 然后再打印本行的行号等信息<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat /etc/passwd | grep "/sbin/nologin" | </span></span><br><span class="line">\ awk <span class="string">'BEGIN&#123;FS=":"&#125;$1=="sshd" &#123;print $1 "\t" $3 "\t" "行号</span></span><br><span class="line"><span class="string">: " NR "\t" "字段数: " NF&#125;'</span></span><br><span class="line"></span><br><span class="line">sshd    74      行号: 13        字段数: 7</span><br></pre></td></tr></table></figure></p>
<p><strong>实例4：</strong> 一个分区统计的小例子<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># df -h |grep -v "Filesystem" | \</span></span><br><span class="line">awk <span class="string">'$1=="/dev/sda1" &#123;print $1 "\t" $5 "\t" "行号:" NR "\t" "字段数:" NF &#125;'</span></span><br><span class="line"></span><br><span class="line">/dev/sda1       13%     行号:6  字段数:6</span><br></pre></td></tr></table></figure></p>
<h3 id="◆awk流程控制◆"><a href="#◆awk流程控制◆" class="headerlink" title="◆awk流程控制◆"></a>◆awk流程控制◆</h3><blockquote>
<p>在awk编程中,因为命令语句非常长,输入格式时需要注意以下内容：</p>
<blockquote>
<p>⦁ 多个条件{动作}可以用空格分割,也可以用回车分割.<br>⦁ 在一个动作中,如果需要执行多个命令,需要用”；”分割,或用回车分割.<br>⦁ 在awk中,变量的赋值与调用都不需要加入”$”符.<br>⦁ 条件中判断两个值是否相同,请使用”==”,以便和变量赋值进行区分.</p>
</blockquote>
</blockquote>
<p><strong>实例1：</strong> 将第2行,到第4行,的内容加起来,最后输出结果<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line">ID      NAME    AGE     SEX     LINUX</span><br><span class="line">1       LY      18      boy     100</span><br><span class="line">2       SC      30      man     150</span><br><span class="line">3       WR      22      man     90</span><br><span class="line">4       ZSX     55      boy     96</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># awk 'NR==2&#123;x=$3&#125; NR==3&#123;y=$3&#125; NR==4&#123;z=$3&#125; &#123;totle=x+y+z;print "Totle is:" totle&#125;' lyshark.log</span></span><br><span class="line">Totle is:0</span><br><span class="line">Totle is:18</span><br><span class="line">Totle is:48</span><br><span class="line">Totle is:70</span><br><span class="line">Totle is:70</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># awk 'NR==2&#123;x=$3&#125; NR==3&#123;y=$3&#125; NR==4&#123;z=$3;totle=x+y+z;print "Totle is:" totle&#125;' lyshark.log</span></span><br><span class="line">Totle is:70</span><br></pre></td></tr></table></figure></p>
<p><strong>实例2：</strong> 统计AGE列,将年龄小于25岁的任过滤出来,并显示 is young man!<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line">ID      NAME    AGE     SEX     LINUX</span><br><span class="line">1       LY      18      boy     10</span><br><span class="line">2       SC      30      man     50</span><br><span class="line">3       WR      22      man     90</span><br><span class="line">4       ZSX     55      boy     96</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log | awk '&#123;if (NR &gt;= 2)&#123;if ($3 &lt; 25) printf $2 " IS Young Man! \n"&#125;&#125;'</span></span><br><span class="line">LY IS Young Man!</span><br><span class="line">WR IS Young Man!</span><br></pre></td></tr></table></figure></p>
<p><strong>实例3：</strong> 统计LINUX列,当出现大于80分的,打印到屏幕上 is good man!<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line">ID      NAME    AGE     SEX     LINUX</span><br><span class="line">1       LY      18      boy     10</span><br><span class="line">2       SC      30      man     50</span><br><span class="line">3       WR      22      man     90</span><br><span class="line">4       ZSX     55      boy     96</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log | awk 'NR&gt;=2 &#123;temp=$5&#125; temp&gt;80 &#123;printf $2 "IS Good Man!\n"&#125;'</span></span><br><span class="line">WRIS Good Man!</span><br><span class="line">ZSXIS Good Man!</span><br></pre></td></tr></table></figure></p>
<h3 id="◆awk函数编写◆"><a href="#◆awk函数编写◆" class="headerlink" title="◆awk函数编写◆"></a>◆awk函数编写◆</h3><p><strong>实例1：</strong> 通过定义的函数格式,去匹配并传递参数<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log</span></span><br><span class="line">ID      NAME    AGE     SEX     LINUX</span><br><span class="line">1       LY      18      boy     10</span><br><span class="line">2       SC      30      man     50</span><br><span class="line">3       WR      22      man     90</span><br><span class="line">4       ZSX     55      boy     96</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.log | awk 'function lyshark(x,y) &#123;printf x "\t" y "\n"&#125;&#123;lyshark($2,$5)&#125;'</span></span><br><span class="line">NAME    LINUX</span><br><span class="line">LY      10</span><br><span class="line">SC      50</span><br><span class="line">WR      90</span><br><span class="line">ZSX     96</span><br></pre></td></tr></table></figure></p>
<p><strong>实例2：</strong> awk中调用脚本,对于小的单行程序来说,将脚本作为命令行自变量传递给awk是非常简单的,而对于多行程序就比较难处理.当程序是多行的时候,使用外部脚本是很适合的.首先在外部文件中写好脚本,然后可以使用awk的-f选项,使其读入脚本并且执.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cat passwd.awk</span></span><br><span class="line">BEGIN &#123;FS=<span class="string">":"</span>&#125;</span><br><span class="line">&#123;<span class="built_in">print</span> <span class="variable">$1</span> <span class="string">"\t"</span> <span class="variable">$3</span>&#125;</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cat /etc/passwd | awk -f passwd.awk</span></span><br><span class="line">root    0</span><br><span class="line">bin     1</span><br><span class="line">daemon  2</span><br><span class="line">adm     3</span><br><span class="line">lp      4</span><br><span class="line">sync    5</span><br><span class="line">shutdown        6</span><br><span class="line">halt    7</span><br><span class="line">mail    8</span><br><span class="line">operator        11</span><br><span class="line">games   12</span><br><span class="line">ftp     14</span><br><span class="line">nobody  99</span><br><span class="line">systemd-network 192</span><br><span class="line">dbus    81</span><br><span class="line">polkitd 999</span><br><span class="line">sshd    74</span><br><span class="line">postfix 89</span><br><span class="line">chrony  998</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="diff-patch-文件比对"><a href="#diff-patch-文件比对" class="headerlink" title="diff/patch 文件比对"></a>diff/patch 文件比对</h2><p>什么时候会用到文件的比对啊？ 通常是『同一个套装软件的不同版本之间,比较配置文件的差异』,很多时候所谓的文件比对,通常是用在 ASCII 纯文字档的比对上的,那么比对文件最常见的就是 diff .</p>
<p>diff命令在最简单的情况下,比较给定的两个文件的不同.如果使用 “-“ 代替 “文件” 参数,则要比较的内容将来自标准输入,diff命令是以逐行的方式,比较文本文件的异同处,如果该命令指定进行目录的比较,则将会比较该目录中具有相同文件名的文件,而不会对其子目录文件进行任何比较操作.</p>
<h3 id="◆diff-生成补丁文件◆"><a href="#◆diff-生成补丁文件◆" class="headerlink" title="◆diff 生成补丁文件◆"></a>◆diff 生成补丁文件◆</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># diff --help</span></span><br><span class="line">Usage: diff [OPTION]... FILES</span><br><span class="line">Compare FILES line by line.</span><br><span class="line"></span><br><span class="line">语法格式：[ diff [选项] 源文件 新文件 &gt; *.patch ]</span><br><span class="line"></span><br><span class="line">        -a          <span class="comment">#将任何文档当做文本文档处理</span></span><br><span class="line">        -b          <span class="comment">#忽略空格造成的不同</span></span><br><span class="line">        -B          <span class="comment">#忽略空白行造成的不同</span></span><br><span class="line">        -I          <span class="comment">#忽略大小写造成的不同</span></span><br><span class="line">        -N          <span class="comment">#当比较目录时，若某个文件只在一个目录中，则另一个目录中视作空文件</span></span><br><span class="line">        -r          <span class="comment">#当比较目录时，递归比较子目录</span></span><br><span class="line">        -u          <span class="comment">#使用同一的输出格式</span></span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">说明： 生成补丁的例子</span><br><span class="line"></span><br><span class="line">1.首先创建两个文件,分别写入以下内容,内容要不同,因为要生成补丁.</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cat old</span></span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cat new</span></span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line">welcome to lyshark blog</span><br><span class="line"></span><br><span class="line">2.利用命令生成补丁文件 *.patch</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># diff -Naur /root/old /root/new &gt; lyshark.patch</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cat lyshark.patch</span></span><br><span class="line">--- /root/old   2018-09-21 05:41:55.487052312 -0400</span><br><span class="line">+++ /root/new   2018-09-21 05:42:10.581184526 -0400</span><br><span class="line">@@ -1 +1,3 @@</span><br><span class="line"> hello world</span><br><span class="line">+</span><br><span class="line">+welcome to lyshark blog</span><br><span class="line"></span><br><span class="line"><span class="comment">#最后,生成的lyshark.patch就是补丁文件了,我们可以使用下面的命令对old文件打补丁了.</span></span><br></pre></td></tr></table></figure>
<h3 id="◆patch-文本打入补丁◆"><a href="#◆patch-文本打入补丁◆" class="headerlink" title="◆patch 文本打入补丁◆"></a>◆patch 文本打入补丁◆</h3><p>patch命令被用于为开放源代码软件安装补丁程序,让用户利用设置修补文件的方式,修改更新原始文件.如果一次仅修改一个文件,可直接在命令列中下达指令依序执行,如果配合修补文件的方式则能一次修补大批文件,这也是Linux系统核心的升级方法之一.</p>
<p>注意：精简模式下没有这个命令,需要执行 <code>yum install -y patch</code> 安装一下<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># patch --help</span></span><br><span class="line">Usage: patch [OPTION]... [ORIGFILE [PATCHFILE]]</span><br><span class="line"></span><br><span class="line">语法格式：[ patch [-pn] 旧文件 &lt; *.patch ]</span><br><span class="line"></span><br><span class="line">        -p：设置要剥离的目录层数   </span><br><span class="line">        n：代表补丁文件中记录的文件old所在目录层数,用于更新old文件时匹配正确路径</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">说明： 给old文件打补丁</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># ls</span></span><br><span class="line">lyshark.patch  new  old</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># patch -p2 old &lt; lyshark.patch</span></span><br><span class="line">patching file old</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cat old</span></span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line">welcome to lyshark blog</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cat new</span></span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line">welcome to lyshark blog</span><br></pre></td></tr></table></figure></p>
<p><br></p>

      
    </div>

    

<!--增加的底部版权代码-->
<div>
      
        
<div class="my_post_copyright">
  <p><span>本文标题:</span><a href="/2018/11/23/Linux 系统管理/Linux正则与文本处理工具-10/">Linux正则与文本处理工具(10)</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 王瑞 的个人博客">王瑞</a></p>
  <p><span>发布时间:</span>2018年11月23日 - 12:11</p>
  <p><span>最后更新:</span>2019年04月16日 - 20:04</p>
  <p><span>原始链接:</span><a href="/2018/11/23/Linux 系统管理/Linux正则与文本处理工具-10/" title="Linux正则与文本处理工具(10)">https://www.mkdirs.com/2018/11/23/Linux 系统管理/Linux正则与文本处理工具-10/</a>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者</p>
</div>

      
</div>
    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux-系统管理/" rel="tag"> <i class="fa fa-tag"></i> Linux 系统管理</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/11/23/Linux 系统管理/Linux系统Bash的常用功能-9/" rel="next" title="Linux系统Bash的常用功能(9)">
                <i class="fa fa-chevron-left"></i> Linux系统Bash的常用功能(9)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/11/25/Linux 系统管理/Linux Shell脚本编程基础-11/" rel="prev" title="Linux Shell脚本编程基础(11)">
                Linux Shell脚本编程基础(11) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="王瑞">
            
              <p class="site-author-name" itemprop="name">王瑞</p>
              <div class="site-description motion-element" itemprop="description">记录点滴技术成长之路</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">101</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://github.com/lyshark" title="GitHub &rarr; https://github.com/lyshark" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="mailto:1181506874@qq.com" title="E-Mail &rarr; mailto:1181506874@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://plus.google.com/lyshark" title="Google &rarr; https://plus.google.com/lyshark" rel="noopener" target="_blank"><i class="fa fa-fw fa-google"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://twitter.com/lyshark" title="Twitter &rarr; https://twitter.com/lyshark" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="http://wpa.qq.com/msgrd?v=3&uin=1181506874&site=hupaiyule&menu=yes" title="QQ &rarr; http://wpa.qq.com/msgrd?v=3&uin=1181506874&site=hupaiyule&menu=yes" rel="noopener" target="_blank"><i class="fa fa-fw fa-qq"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://weixin.qq.com" title="Wechat &rarr; https://weixin.qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-weixin"></i></a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础正则表达式"><span class="nav-text">基础正则表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展正则表达式"><span class="nav-text">扩展正则表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Grep-行处理工具"><span class="nav-text">Grep 行处理工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cut-列提取工具"><span class="nav-text">Cut 列提取工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sed-流编辑器"><span class="nav-text">Sed 流编辑器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Printf-文本格式化"><span class="nav-text">Printf 文本格式化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Awk-正则表达工具"><span class="nav-text">Awk 正则表达工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#◆awk常用例子◆"><span class="nav-text">◆awk常用例子◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆begin-与-end◆"><span class="nav-text">◆begin 与 end◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆awk关系运算◆"><span class="nav-text">◆awk关系运算◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆awk正则搜索◆"><span class="nav-text">◆awk正则搜索◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆awk内置变量◆"><span class="nav-text">◆awk内置变量◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆awk流程控制◆"><span class="nav-text">◆awk流程控制◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆awk函数编写◆"><span class="nav-text">◆awk函数编写◆</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#diff-patch-文件比对"><span class="nav-text">diff/patch 文件比对</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#◆diff-生成补丁文件◆"><span class="nav-text">◆diff 生成补丁文件◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆patch-文本打入补丁◆"><span class="nav-text">◆patch 文本打入补丁◆</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">

<!-- 屏蔽版权开始 -->
&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王瑞</span>
<!-- 屏蔽版权结束 -->

  

  
</div>









        








        
      </div>
    </footer>

    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>




  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
