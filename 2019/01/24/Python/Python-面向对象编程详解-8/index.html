<!DOCTYPE html>













<html class="theme-next gemini" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">











<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.0.1',
    sidebar: {"position":"left","display":"hide","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: true,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"expandIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Python 的创始人为吉多·范罗苏姆(Guido van Rossum).1989年的圣诞节期间,吉多·范罗苏姆为了在阿姆斯特丹打发时间,决心开发一个新的脚本解释程序,作为ABC语言的一种继承.Python是纯粹的自由软件,源代码和解释器CPython遵循 GPL(GNU General Public License)协议.关于python的哲学：python崇尚:”优雅”、”明确”、”简单”,">
<meta name="keywords" content="Python">
<meta property="og:type" content="article">
<meta property="og:title" content="Python 面向对象编程详解(8)">
<meta property="og:url" content="https://www.mkdirs.com/2019/01/24/Python/Python-面向对象编程详解-8/index.html">
<meta property="og:site_name" content="我的个人博客">
<meta property="og:description" content="Python 的创始人为吉多·范罗苏姆(Guido van Rossum).1989年的圣诞节期间,吉多·范罗苏姆为了在阿姆斯特丹打发时间,决心开发一个新的脚本解释程序,作为ABC语言的一种继承.Python是纯粹的自由软件,源代码和解释器CPython遵循 GPL(GNU General Public License)协议.关于python的哲学：python崇尚:”优雅”、”明确”、”简单”,">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-01-29T06:28:26.927Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python 面向对象编程详解(8)">
<meta name="twitter:description" content="Python 的创始人为吉多·范罗苏姆(Guido van Rossum).1989年的圣诞节期间,吉多·范罗苏姆为了在阿姆斯特丹打发时间,决心开发一个新的脚本解释程序,作为ABC语言的一种继承.Python是纯粹的自由软件,源代码和解释器CPython遵循 GPL(GNU General Public License)协议.关于python的哲学：python崇尚:”优雅”、”明确”、”简单”,">



  <link rel="alternate" href="/atom.xml" title="我的个人博客" type="application/atom+xml">




  <link rel="canonical" href="https://www.mkdirs.com/2019/01/24/Python/Python-面向对象编程详解-8/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Python 面向对象编程详解(8) | 我的个人博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">我的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.mkdirs.com/2019/01/24/Python/Python-面向对象编程详解-8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王瑞">
      <meta itemprop="description" content="记录点滴技术成长之路">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Python 面向对象编程详解(8)

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-24 20:41:22" itemprop="dateCreated datePublished" datetime="2019-01-24T20:41:22+08:00">2019-01-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-01-29 14:28:26" itemprop="dateModified" datetime="2019-01-29T14:28:26+08:00">2019-01-29</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    
    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Python 的创始人为吉多·范罗苏姆(Guido van Rossum).1989年的圣诞节期间,吉多·范罗苏姆为了在阿姆斯特丹打发时间,决心开发一个新的脚本解释程序,作为ABC语言的一种继承.Python是纯粹的自由软件,源代码和解释器CPython遵循 GPL(GNU General Public License)协议.关于python的哲学：python崇尚:”优雅”、”明确”、”简单”,Python是用最简单最优雅最明确的方法来解决问题.</p>
<a id="more"></a>
<p>面向对象的程序设计提供了一种新的思维方式,软件设计的焦点不再是程序的逻辑流程,而是软件或程序中的对象以及对象之间的关系,使用面向对象的思想进行程序设计,能够更好地设计软件架构,维护软件模块,并易于框架和组件的重用.</p>
<p>Python 支持面向过程、面向对象、函数式编程等多种编程范式,且不强制我们使用任何一种编程范式,我们可以使用过程式编程编写任何程序,在编写小程序时,基本上不会有问题.但对于中等和大型项目来说,面向对象将给我们带来很多优势.接下来将结合面向对象的基本概念和Python语法的特性讲解面向对象的编程.<br><br></p>
<h2 id="面向对象编程简介"><a href="#面向对象编程简介" class="headerlink" title="面向对象编程简介"></a>面向对象编程简介</h2><p>面向对象,<code>OOP英文全称(Object-Oriented Programming)</code>是一种高效的编程思路,面向对象技术已经成为当今软件设计和开发领域的主流技术,面向对象编程是一种编程方式,使用 “类” 和 “对象” 来实现,所以面向对象编程其实就是对 “类” 和 “对象” 的使用,类就是一个模板,模板里可以包含多个方法(函数),方法里实现各种各样的功能,对象则是根据模板创建的实例,通过实例对象可以执行类中的方法,每个对象都拥有相同的方法,但各自的数据可能不同.</p>
<p>在面向对象的设计中,程序员可以创建任何新的类型,这些类型可以描述每个对象包含的数据和特征,类是一些对象的抽象,隐藏了对象内部复杂的结构和实现,类由变量和函数两部分构成,类中的变量称为<code>数据成员</code>,类中的函数称为<code>成员函数</code>,类是对客观事物的抽象,而对象是类的实例化后的实体.</p>
<p>简单点说,”面向对象”是一种编程范式,而编程范式是按照不同的编程特点总结出来的编程方式,俗话说,条条大路通罗马,也就说我们使用不同的方法都可以达到最终的目的,但是有些办法比较快速、安全且效果好,有些方法则效率低下且效果不尽人意.同样,编程也是为了解决问题,而解决问题可以有多种不同的视角和思路,前人把其中一些普遍适用且行之有效的编程模式归结为”范式”,常见的编程范式有:</p>
<blockquote>
<p>● 面向过程编程：OPP(Procedure Oriented Programing)<br>● 面向对象编程：OOP(Object Oriented Programing)<br>● 面向函数编程：FP(Functional Programing)</p>
</blockquote>
<blockquote>
<p>面向对象编程有3个目标:重用性、灵活性、扩展性,而目标的几个主要特点:</p>
<blockquote>
<p>● 封装:可以隐藏实现细节,使代码模块化,屏蔽代码的实现细节,对外只提供接口<br>● 继承:可以通过扩展已存在的类来实现代码重用,避免重复编写相同的代码<br>● 多态:多态是为了实现接口重用,使得多个不同的类之间的灵活调用</p>
</blockquote>
</blockquote>
<p>说到这里,我们已经把面向对象的基本作用,特性,应用场景介绍完了,这里只是个人笔记,无法做到面面俱到,如果想要深入了解,请自行去看一些学习手册,以上内容大部分摘抄自书籍中的重点,接下来我们将围绕<code>封装,继承,多态</code>等面向对象核心概念进行说明.<br><br></p>
<h2 id="面向对象—-gt-封装"><a href="#面向对象—-gt-封装" class="headerlink" title="面向对象—&gt;封装"></a>面向对象—&gt;封装</h2><p>封装是面向对象的主要特征之一,是对象和类概念的主要特性.简单的说,类就是封装了数据以及操作这些数据的方法的逻辑实体,它向外暴露部分数据和方法,屏蔽具体的实现细节,除此之外,在一个对象内部,某些数据或方法可以是私有的,这些私有的数据或方法是不允许外界访问的.通过这种方式,对象对内部数据提供了不同级别的保护.</p>
<p>封装,也就是把客观事物封装成抽象的类,并且类可以把自己的数据和方法只让可信的类或者对象操作,对不可信的进行信息隐藏,封装一般是通过在类中封装数据,而通过对象或者self获取,和其他面向对象的语言类似,也是通过构造函数来进行数据封装,说白了就是,将一些功能相近的函数写在一起,方便我们的调用与维护.</p>
<h3 id="◆实现简单的类封装◆"><a href="#◆实现简单的类封装◆" class="headerlink" title="◆实现简单的类封装◆"></a>◆实现简单的类封装◆</h3><p>在Python中,定义类是通过<code>class关键字</code>,class后面紧接着是类名,类名通常是大写开头的单词,紧接着是<code>()小括号</code>,小括号内可以写<code>(要继承的类名称)</code>,表示该类是从哪个类继承下来的,可以有多个<code>父类(基类)</code>,通常如果没有合适的继承类,就使用<code>object类</code>,这是所有类最终都会继承的类,也可以不写,不写的话默认也是加载的.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">lyshark</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age,sex)</span>:</span></span><br><span class="line"><span class="meta">... </span>            self.name = name</span><br><span class="line"><span class="meta">... </span>            self.age = age</span><br><span class="line"><span class="meta">... </span>            self.sex = sex</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp=lyshark(<span class="string">"lyshark"</span>,<span class="string">"22"</span>,<span class="string">"Man"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"姓名:%s   年龄:%s   性别:%s"</span>%(temp.name,temp.age,temp.sex))</span><br><span class="line">姓名:lyshark   年龄:<span class="number">22</span>   性别:Man</span><br></pre></td></tr></table></figure>
<p>以上就是创建的一个<code>lyshark</code>类,如上所示<code>__init__()</code>叫做初始化方法(或构造方法),在类实例化时,这个方法(虽然它是函数形式,但在类中就不叫函数了叫方法)会自动执行,进行一些初始化的动作,所以我们这里写的<code>__init__(self,name,age,sex)</code>就是要在创建一个角色时给它设置这些属性,也就是做一些初始化赋值工作.</p>
<blockquote>
<p>呈上参数<code>self</code>的工作流程是这样的.</p>
<blockquote>
<p>● 在内存中开辟一块空间指向lyshark这个变量名,也就是相当于一个指针函数<br>● 实例化这个类首先执行其中的<code>__init__()</code>,执行后会自动的将参数传递给内部变量<br>● 然后自动执行<code>__init__()</code>构造方法,开辟内存空间,此时<code>self.* = *</code>两个变量数据一致了</p>
</blockquote>
</blockquote>
<p>创建对象的过程称为实例化,还是看如上代码,<code>temp=lyshark()</code>这一句话就是将<code>lyshark类</code>实例化,当一个对象被创建后,包含3个方面的特性：对象的句柄、属性和方法,对象的句柄用于区分不同的对象,当对象被创建后,该对象会获取一块存储空间,存储空间的地址即为对象的标识,对象的属性和方法与类的成员变量和成员函数相对应.</p>
<h3 id="◆使用公有属性封装◆"><a href="#◆使用公有属性封装◆" class="headerlink" title="◆使用公有属性封装◆"></a>◆使用公有属性封装◆</h3><p>类由属性和方法组成,类的属性是对数据的封装,而类的方法则表示对象具有的行为,类通常由函数(实例方法)和变量(类变量)组成,如下是使用公有属性封装的数据成员,可以看到,在类的外部,我们是可以使用<code>temp.name=&quot;xxoo&quot;</code>的方式修改这个数据成员的数值的,然后再次调用打印函数,则发现数据被改动了,这样做显然是不够安全的.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># =====================以下内容是类的定义====================</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">lyshark</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span>          <span class="comment">#构造函数,初始化数据</span></span><br><span class="line"><span class="meta">... </span>            self.name = name              <span class="comment">#封装的数据成员</span></span><br><span class="line"><span class="meta">... </span>            self.age = age</span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">my_print</span><span class="params">(self)</span>:</span>                   <span class="comment">#封装的成员函数</span></span><br><span class="line"><span class="meta">... </span>            print(<span class="string">"我的名字是:%s 我的年龄是:%s"</span>%(self.name,self.age))</span><br><span class="line">...</span><br><span class="line"><span class="comment"># =========================================================</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp=lyshark(<span class="string">"wangrui"</span>,<span class="string">"22"</span>)              <span class="comment">#类的实例化,将参数传入类中</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp.my_print()                           <span class="comment">#调用类中的指定方法,打印数据</span></span><br><span class="line">我的名字是:wangrui 我的年龄是:<span class="number">22</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(temp.name)                          <span class="comment">#直接调用类中的数据成员</span></span><br><span class="line">wangrui</span><br><span class="line"><span class="comment"># ===============改变数据成员,再次调用看看===================</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp.name=<span class="string">"xxoo"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp.my_print()</span><br><span class="line">我的名字是:xxoo 我的年龄是:<span class="number">22</span></span><br><span class="line"><span class="comment"># =========================================================</span></span><br></pre></td></tr></table></figure>
<p><strong>小总结:</strong> 1.公有属性或者静态属性,可以直接通过类直接访问,也可以直接通过实例进行访问.2.通过类的某个实例对公有属性进行修改,实际上对为该实例添加了一个与类的公有属性名称相同的成员属性,对真正的公有属性是没有影响的,因此它不会影响其他实例获取的该公有属性的值.3.通过类对公有属性进行修改,必然是会改变公有属性原有的值,他对该类所有的实例是都有影响的.</p>
<h3 id="◆使用私有属性封装◆"><a href="#◆使用私有属性封装◆" class="headerlink" title="◆使用私有属性封装◆"></a>◆使用私有属性封装◆</h3><p>在上面的小例子中,我们也发现了一些缺陷问题,接下来则看看私有属性封装的技巧,私有属性和成员属性一样,是在<code>__init__</code>方法中进行声明,但是属性名需要以双下划线<code>__开头</code>,私有属性是一种特殊的成员属性,它只允许在实例对象的内部(成员方法或私有方法中)访问,而不允许在实例对象的外部通过实例对象或类来直接访问,也不能被子类继承,总之一句话:<code>私有属性只有类的内部可以调用</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># =====================以下内容是类的定义====================</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lyshark</span><span class="params">()</span>:</span></span><br><span class="line">        name = <span class="string">"lyshark"</span>                    <span class="comment">#定义公有属性(类变量,可共享数据)</span></span><br><span class="line">        __age = <span class="number">22</span>                          <span class="comment">#定义私有属性(类变量)</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>                 <span class="comment">#定义构造函数,初始化数据</span></span><br><span class="line">                self.__like = <span class="string">"soccer"</span>      <span class="comment">#定义私有实例属性(实例变量)</span></span><br><span class="line">                self.hobby = <span class="string">"xxoo"</span>         <span class="comment">#定义公有实例属性</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">my_print</span><span class="params">(self)</span>:</span>                 <span class="comment">#定义公有函数,外部可以调用</span></span><br><span class="line">                print(<span class="string">"我的名字: %s"</span>%self.name)</span><br><span class="line">                print(<span class="string">"我的年龄: %s"</span>%self.__age)</span><br><span class="line">                print(<span class="string">"我的爱好: %s"</span>%self.__like)</span><br><span class="line">                print(<span class="string">"其他: %s"</span>%self.hobby)</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__new_test</span><span class="params">(self)</span>:</span>               <span class="comment">#定义私有函数,只能内部类调用</span></span><br><span class="line">		print(<span class="string">"hello world"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span>                  <span class="comment">#定义析构函数,清理数据</span></span><br><span class="line">        	self.__nobody = <span class="string">"end"</span></span><br><span class="line">        	<span class="comment">#print("函数执行结束,销毁无用的数据. %s"%self.__nobody)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># =================(公有/私有)方法的调用====================</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp=lyshark()                          <span class="comment">#实例化对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp.my_print()                         <span class="comment">#调用类中方法(公有方法)</span></span><br><span class="line">我的名字: lyshark</span><br><span class="line">我的年龄: <span class="number">22</span></span><br><span class="line">我的爱好: soccer</span><br><span class="line">其他: xxoo</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp.__new_test()                       <span class="comment">#调用私有方法,则会报错</span></span><br><span class="line"><span class="comment"># =================(公有/私有)属性的调用====================</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(lyshark.name)                     <span class="comment">#调用公有属性则成功</span></span><br><span class="line">lyshark</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(lyshark.__age)                    <span class="comment">#调用私有属性,则会报错</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(lyshark.__like)</span><br><span class="line"><span class="comment"># =========================================================</span></span><br></pre></td></tr></table></figure>
<p><strong>小总结:</strong> 通过对<code>公有属性</code>和<code>私有属性</code>的数据对比,我们可以清晰的看到他们之间的差距,其总结一下就是,1.私有变量不能通过类直接访问,2.私有变量也不能通过实例对象直接访问,3.私有变量可以通过成员方法进行访问.4.类变量一般可以用于共享两个实例化之间的数据,而实例变量则只作用于当前实例.</p>
<h3 id="◆将类封装进对象中◆"><a href="#◆将类封装进对象中◆" class="headerlink" title="◆将类封装进对象中◆"></a>◆将类封装进对象中◆</h3><p>除了上面的一些经常用到的封装以外,还有一个比较难理解的封装格式,就是下面这种,它的意思是将一个类实例化后的对象当作一个参数传递到另一个类中,那么在另一个类中我们就可以访问到被传入类中的数据成员以及成员函数的调用啦.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">main</span><span class="params">(object)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,obj)</span>:</span>          <span class="comment">#OBJ参数用来接收对象</span></span><br><span class="line">                self.name=name</span><br><span class="line">                self.obj=obj</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">uuid</span><span class="params">(object)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,uid,age,sex)</span>:</span></span><br><span class="line">                self.uid=uid</span><br><span class="line">                self.age=age</span><br><span class="line">                self.sex=sex</span><br><span class="line"></span><br><span class="line">temp=uuid(<span class="number">1001</span>,<span class="number">22</span>,<span class="string">"Man"</span>)                     <span class="comment">#首先给UUID类初始化</span></span><br><span class="line">lyshark=main(<span class="string">"lyshark"</span>,temp)                 <span class="comment">#将生成的TEMP对象传递给main</span></span><br><span class="line"><span class="comment"># =========================================================</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lyshark.name</span><br><span class="line"><span class="string">'lyshark'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lyshark.obj.uid                          <span class="comment">#最后通过多级指针的方式访问数据</span></span><br><span class="line"><span class="number">1001</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lyshark.obj.sex</span><br><span class="line"><span class="string">'Man'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lyshark.obj.age</span><br><span class="line"><span class="number">22</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="面向对象—-gt-继承"><a href="#面向对象—-gt-继承" class="headerlink" title="面向对象—&gt;继承"></a>面向对象—&gt;继承</h2><p>面向对象编程(OOP)语言的一个主要功能就是”继承”,继承是指这样一种能力,它可以使用现有类的所有功能,并在无需重新编写原来的类的情况下对这些功能进行扩展.</p>
<p>继承是面向对象的重要特性之一,通过继承可以创建新类,其目的是使用或修改现有类的行为,原始的类称为父类或超类,新类称为子类或派生类,继承机制可以实现代码的重用,继承的本质是将父类中的方法全部复制一份到子类中,Python里面的继承可以多继承,通过继承,可以获得父类的功能,继承的时候,如果父类中有重复的方法,优先找自己(子类).</p>
<h3 id="◆继承基类普通函数◆"><a href="#◆继承基类普通函数◆" class="headerlink" title="◆继承基类普通函数◆"></a>◆继承基类普通函数◆</h3><p>以下是个基本小例子,则可说明继承的关系,首先<code>base()</code>是一个基类,而<code>expand()</code>则是一个派生类,派生自<code>base()</code>,如下虽然派生列没有任何功能,但我们依然可以调用printf()函数打印传入的数据,则可说明,函数是继承的base类里面的.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span><span class="params">()</span>:</span>               <span class="comment">#这个类是基类</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">                self.name = name</span><br><span class="line">                self.age = age</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">printf</span><span class="params">(self)</span>:</span></span><br><span class="line">                print(<span class="string">"姓名:%s  年龄:%s"</span>%(self.name,self.age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">expand</span><span class="params">(base)</span>:</span>         <span class="comment">#新建类expand继承base基类的方法</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># =========================================================</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp=expand(<span class="string">"lyshark"</span>,<span class="string">"22"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp.printf()</span><br><span class="line">姓名:lyshark  年龄:<span class="number">22</span></span><br></pre></td></tr></table></figure>
<h3 id="◆继承基类构造函数◆"><a href="#◆继承基类构造函数◆" class="headerlink" title="◆继承基类构造函数◆"></a>◆继承基类构造函数◆</h3><p>当然我们也可以继承父类的构造函数,以及给相应的子类添加新的属性字段,还可以直接通过<code>super()</code>方法,直接在子类中的函数体里调用父类里面的函数,并返回执行结果给调用者.</p>
<p><strong>直接继承构造函数:</strong> 新建<code>expand()</code>子类,并继承<code>base()</code>基类的构造函数,并能够数据在子类中打印父类属性.<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">                self.name = name</span><br><span class="line">                self.age = age</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">printf</span><span class="params">(self)</span>:</span></span><br><span class="line">                print(<span class="string">"姓名:%s  年龄:%s"</span>%(self.name,self.age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">expand</span><span class="params">(base)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">                super(expand,self).__init__(name,age)      <span class="comment">#推荐使用本功能实现继承</span></span><br><span class="line">                <span class="comment">#base.__init__(self,name,age)              #此处和上面实现的功能相等</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">printf</span><span class="params">(self)</span>:</span></span><br><span class="line">                print(<span class="string">"姓名:%s  年龄:%s"</span>%(self.name,self.age))</span><br><span class="line"></span><br><span class="line"><span class="comment"># =========================================================</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp=base(<span class="string">"lyshark"</span>,<span class="string">"22"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp.printf()</span><br><span class="line">姓名:lyshark  年龄:<span class="number">22</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp=expand(<span class="string">"lyshark"</span>,<span class="string">"22"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp.printf()</span><br><span class="line">姓名:lyshark  年龄:<span class="number">22</span></span><br></pre></td></tr></table></figure></p>
<p><strong>添加新字段:</strong> 在父类<code>base()</code>的原始字段的基础上重写,给子类<code>expand()</code>添加一个新的字段<code>sex</code>,并能够传递参数.<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span><span class="params">()</span>:</span>                                           <span class="comment">#定义的父类</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">                self.name = name</span><br><span class="line">                self.age = age</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">printf</span><span class="params">(self)</span>:</span></span><br><span class="line">                print(<span class="string">"姓名:%s  年龄:%s"</span>%(self.name,self.age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">expand</span><span class="params">(base)</span>:</span>                                     <span class="comment">#定义的子类</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age,sex)</span>:</span></span><br><span class="line">                super(expand,self).__init__(name,age)   <span class="comment">#继承父类的属性</span></span><br><span class="line">                self.sex = sex                          <span class="comment">#新添加的一个属性</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">printf</span><span class="params">(self)</span>:</span></span><br><span class="line">                print(<span class="string">"姓名:%s  年龄:%s  性别:%s "</span>%(self.name,self.age,self.sex))</span><br><span class="line"></span><br><span class="line"><span class="comment"># =========================================================</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp=base(<span class="string">"lyshark"</span>,<span class="string">"22"</span>)                          <span class="comment">#原始基类,没有第三个字段</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp.printf()</span><br><span class="line">姓名:lyshark  年龄:<span class="number">22</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp=expand(<span class="string">"lyshark"</span>,<span class="string">"22"</span>,<span class="string">"Man"</span>)                  <span class="comment">#在不影响父类情况下,重写新的字段</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp.printf()</span><br><span class="line">姓名:lyshark  年龄:<span class="number">22</span>  性别:Man</span><br></pre></td></tr></table></figure></p>
<p><strong>继承父类函数(强制):</strong> 如果想在子类中使用父类的其中一个方法,可以使用以下的方式来实现.<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span><span class="params">(object)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">printf</span><span class="params">(self)</span>:</span></span><br><span class="line">                print(<span class="string">"================================"</span>)</span><br><span class="line">                print(<span class="string">"执行函数...."</span>)</span><br><span class="line">                print(<span class="string">"================================"</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">expand</span><span class="params">(base)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(self)</span>:</span></span><br><span class="line">                ret=super(expand,self).printf()      <span class="comment">#强制调用父类中的printf方法</span></span><br><span class="line">                <span class="keyword">return</span> ret                           <span class="comment">#将结果返回给调用者</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># =========================================================</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp=base()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp.printf()                                    <span class="comment">#调用基类的方法</span></span><br><span class="line">================================</span><br><span class="line">执行函数....</span><br><span class="line">================================</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj=expand()                                     <span class="comment">#在子类中调用基类方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ret=obj.fun()                                    <span class="comment">#将返回值付给ret并打印</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(ret)</span><br><span class="line">================================</span><br><span class="line">执行函数....</span><br><span class="line">================================</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h3 id="◆多类继承与多继承◆"><a href="#◆多类继承与多继承◆" class="headerlink" title="◆多类继承与多继承◆"></a>◆多类继承与多继承◆</h3><p><strong>简单的多继承:</strong> 此处我们实现一个简单的多继承,这里我们会在代码中说明他们的执行顺序,废话不多说,看下图.<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"我是A类里面的函数"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">fun1</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"我是B类里面的函数1"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">fun2</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"我是B类里面的函数2"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A,B)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"我是C类里面的函数"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># =========================================================</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp=C()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp.fun()        <span class="comment">#默认调用C类,如果C里面有fun()函数则默认执行自身</span></span><br><span class="line">我是C类里面的函数      <span class="comment">#如果自身没有,才会去基类里面去找fun()函数的存在</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp.fun1()       <span class="comment">#由于C类中没有这个方法,它会去B或A类里面去找</span></span><br><span class="line">我是B类里面的函数<span class="number">1</span>      <span class="comment">#这也为我们重写函数提供了可能性,我们只需修改C类且名称相同即可实现重写</span></span><br></pre></td></tr></table></figure></p>
<p><strong>复杂的多继承:</strong> 下面是重点和难点,在其他源码都是这么干的,属于嵌套继承如果开发新程序,则最好不要这么干,最后连自己都懵逼了.<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'bar'</span>)</span><br><span class="line">        self.f1()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'b'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'c'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'d'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span><span class="params">(C,D)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">temp=D()</span><br><span class="line">temp.bar()</span><br></pre></td></tr></table></figure></p>
<p><strong>多类继承(实例):</strong> 多继承也是一种解决问题的方式,这里我们通过例子,来演示一下多继承的应用场景,如下我们将添加三个类分别是<code>Person(人类)</code>作为父类使用,在创建两个派生类,一个是<code>Teacher(老师)</code>,另一个是<code>Student(学生)</code>两个类,这两个类派生于<code>Person(人类)</code>,都属于人类都有共同属性.</p>
<p>1.我们首先创建一个基类<code>Person()</code>,来描述人类这个范围,当然人类具有一些公共属性如姓名,年龄无论老师学生都有.<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">walk</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'%s is walking...'</span> % self.name)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'%s is talking...'</span> % self.name )</span><br></pre></td></tr></table></figure></p>
<p>2.在以上基类的基础上派生一个<code>Teacher</code>子类,使用父类的几个属性和方法.<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, level, salary)</span>:</span></span><br><span class="line">        super(Teacher, self).__init__(name, age)</span><br><span class="line">        self.level = level</span><br><span class="line">        self.salary = salary</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">teach</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'%s is teaching...'</span> % self.name)</span><br></pre></td></tr></table></figure></p>
<p>3.最后创建一个学生类<code>Student</code>,同样和父类公用一些基本属性和方法.<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, class_)</span>:</span></span><br><span class="line">        Person.__init__(self, name, age)</span><br><span class="line">        self.class_ = class_</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">study</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'%s is studying...'</span> % self.name)</span><br></pre></td></tr></table></figure></p>
<p>4.最后直接实例化,并传递两个参数,打印看结果,很好理解.<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = Teacher(<span class="string">'张老师'</span>, <span class="number">33</span>, <span class="string">'高级教师'</span>, <span class="number">20000</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = Student(<span class="string">'小明'</span>, <span class="number">13</span>, <span class="string">'初一3班'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1.talk()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1.walk()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1.teach()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.talk()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.walk()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.study()</span><br><span class="line"></span><br><span class="line">张老师 <span class="keyword">is</span> talking...</span><br><span class="line">张老师 <span class="keyword">is</span> walking...</span><br><span class="line">张老师 <span class="keyword">is</span> teaching...</span><br><span class="line">小明 <span class="keyword">is</span> talking...</span><br><span class="line">小明 <span class="keyword">is</span> walking...</span><br><span class="line">小明 <span class="keyword">is</span> studying...</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="面向对象—-gt-多态"><a href="#面向对象—-gt-多态" class="headerlink" title="面向对象—&gt;多态"></a>面向对象—&gt;多态</h2><p>多态性(polymorphisn)是允许你将父对象设置成为和一个或更多的他的子对象相等的技术,赋值之后,父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作,多态的作用:我们知道,封装可以隐藏实现细节,使得代码模块化,继承可以扩展已存在的代码模块,它们的目的都是为了实现<code>代码的重用</code>,而多态则是为了实现另一个目的那就是<code>接口的重用</code>,多态的作用,就是为了类在继承和派生的时候,保证使用“家谱”中任一类的实例的某一属性时的正确调用,一句话概括,就是为了实现接口的重用.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'%s: 喵喵喵!'</span> %self.name)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'%s: 汪！汪！汪！'</span> %self.name)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(obj)</span>:</span>            <span class="comment">#这里制定一个接口,后期直接调用它</span></span><br><span class="line">    obj.talk()</span><br><span class="line"></span><br><span class="line"><span class="comment"># =========================================================</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c1 = Cat(<span class="string">"catcat"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d1 = Dog(<span class="string">"dogdog"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(c1)              <span class="comment">#这里调用相同的方法,传入的数据不同</span></span><br><span class="line">catcat: 喵喵喵!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(d1)              <span class="comment">#这里调用相同的方法,传入的数据不同</span></span><br><span class="line">dogdog: 汪！汪！汪！</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="面向对象—-gt-包装"><a href="#面向对象—-gt-包装" class="headerlink" title="面向对象—&gt;包装"></a>面向对象—&gt;包装</h2><p>在上面的面向对象概念中提到过,通常类中封装的是<code>数据(数据成员)</code>和操作<code>数据的方法(成员函数)</code>这两种东西组成形成了一个类的雏形,数据就是属性,且上面已经介绍过了属性无外乎这几种分类,<code>公有属性/类变量</code>、<code>成员属性/实例变量</code>和<code>私有属性</code>,除了这些属性以外,现在我们来说说类中的方法,类中的方法分为以下几种:</p>
<blockquote>
<p>● 成员方法：通常情况下,它们与成员属性相似,是通过类的实例对象去访问,成员方法的第一个参数通常写成<code>self</code>,以标明这是一个成员方法<br>● 私有方法：以双下划线<code>(__)</code>开头的成员方法就是私有方法,与私有属性类似,私有只能在实例对象内部访问,且不能被子类继承<br>● 类的方法：使用<code>@classmethod</code>来装饰的成员方法就叫做类方法,定义为类方法后,只能访问类变量,而不能访问实例变量<br>● 静态方法：使用<code>@staticmethod</code>来装饰的成员方法就叫做静态方法,静态方法已经与这个类没有任何关联了,通常情况下用来编写工具包<br>● 属性方法：把一个方法变成静态属性,可以像访问成员属性那样去访问这个方法,且无法通过<code>()</code>小括号,传递参数</p>
</blockquote>
<h3 id="◆类的方法◆"><a href="#◆类的方法◆" class="headerlink" title="◆类的方法◆"></a>◆类的方法◆</h3><p>上面的简单介绍也说明了,通常情况下我们如果在成员函数的上方加上<code>@classmethod</code>来装饰的成员方法就叫做类方法,它要求第一次参数必须是当前类,与<code>公有属性/静态属性</code>相似,除了可通过实例对象进行访问,还可以直接通过类名去访问,且第一个参数表示的是当前类,通常写为cls,另外需要说明的是,类方法只能访问公有属性,不能访问成员属性,因此第一个参数传递的是代表当前类的cls,而不是表示实例对象的self.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lyshark</span><span class="params">(object)</span>:</span></span><br><span class="line">    name=<span class="string">"wangrui"</span>                       <span class="comment">#赋值等待被调用</span></span><br><span class="line">    age=<span class="string">"22"</span></span><br><span class="line">    sex=<span class="string">"Man"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,x,y,z)</span>:</span></span><br><span class="line">        self.x=x</span><br><span class="line">        self.y=y</span><br><span class="line">        self.z=z</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod                         #声明下方的函数为类方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printf</span><span class="params">(cls)</span>:</span>                     <span class="comment">#此函数只能调用类变量,而不能调用成员属性</span></span><br><span class="line">        print(<span class="string">"姓名:%s 年龄:%s 性别:%s"</span>%(cls.name,cls.age,cls.sex))</span><br><span class="line"></span><br><span class="line"><span class="comment"># =========================================================</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp=lyshark(<span class="string">"100"</span>,<span class="string">"100"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp.printf()</span><br><span class="line">姓名:wangrui 年龄:<span class="number">22</span> 性别:Man</span><br></pre></td></tr></table></figure>
<p>如果我们将以上的打印函数变量修改调用实例变量,则会出现错误,这是因为装饰器<code>classmethod</code>的存在,如果屏蔽掉装饰器代码,则就可是成功调用啦,只不过调用的不再是类变量中的数据,而是实例变量中的数据.<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,x,y,z)</span>:</span></span><br><span class="line">        self.x=x</span><br><span class="line">        self.y=y</span><br><span class="line">        self.z=z</span><br><span class="line"></span><br><span class="line">    <span class="comment">#@classmethod                      #此装饰器存在,不允许调用实例变量</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printf</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"姓名:%s 年龄:%s 性别:%s"</span>%(self.x,self.y,self.z))</span><br><span class="line"></span><br><span class="line"><span class="comment"># =========================================================</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp=lyshark(<span class="string">"lyshark"</span>,<span class="string">"33"</span>,<span class="string">"Man"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp.printf()</span><br><span class="line">姓名:lyshark 年龄:<span class="number">22</span> 性别:Man</span><br></pre></td></tr></table></figure></p>
<h3 id="◆静态方法◆"><a href="#◆静态方法◆" class="headerlink" title="◆静态方法◆"></a>◆静态方法◆</h3><p>上面的简单介绍也说明了,通常情况下我们如果在成员函数的上方加上<code>@staticmethod</code>来装饰的成员方法就叫做静态方法,静态方法是类中的函数,不需要实例.静态方法主要是用来存放逻辑性的代码,逻辑上属于类,但是和类本身没有关系,也就是说在静态方法中,不会涉及到类中的属性和方法的操作.可以理解为,静态方法是个独立的、单纯的函数,它仅仅托管于某个类的名称空间中,便于使用和维护,通常情况下我们可以用它来实现一个私有的工具包.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lyshark</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(x,y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">(x,y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x-y</span><br><span class="line"></span><br><span class="line"><span class="comment"># =========================================================</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment">#temp=lyshark()               #这里无需实例化</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text=lyshark.sum(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"两数之和:%s"</span>%text)</span><br><span class="line">两数之和:<span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text=lyshark.sub(<span class="number">100</span>,<span class="number">50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"两数之差:%s"</span>%text)</span><br><span class="line">两数之差:<span class="number">50</span></span><br></pre></td></tr></table></figure>
<p>以上的小例子就是一个典型的封装,因为我们无法调用类中的其他数据,所以直接将它作为一个工具箱使用是最恰当不过的啦,当然这个功能至今为止在开发中也没怎末用到过.</p>
<h3 id="◆属性方法◆"><a href="#◆属性方法◆" class="headerlink" title="◆属性方法◆"></a>◆属性方法◆</h3><p>property是一种特殊的属性,访问它时会执行一段功能(函数)然后返回值,他可以把一个方法变成静态属性,可以像访问成员属性那样去访问这个方法,且无法通过<code>()</code>小括号,传递参数,它的第一个参数也必须是当前实例对象,且该方法必须要有返回值.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lyshark</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,weight,height)</span>:</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.weight=weight</span><br><span class="line">        self.height=height</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight + self.height</span><br><span class="line"></span><br><span class="line"><span class="comment"># =========================================================</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp=lyshark(<span class="string">"wangrui"</span>,<span class="number">75</span>,<span class="number">1.88</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(temp.foo)             <span class="comment">#此处我们直接调用这个属性,并没有传递参数</span></span><br><span class="line"><span class="number">76.88</span></span><br></pre></td></tr></table></figure>
<p>上面的小例子我们可以看到,实例化一个类以后,在调用内部的foo函数的时候,并没有添加括号,然而还是调用成功了,这种特性的使用方式遵循了统一访问的原则,即对外屏蔽细节,只需要像调用变量一样的使用它即可,给用户的感觉就是调用了一个类中的变量.</p>
<p>由于新式类中具有三种访问方式,我们可以根据他们几个属性的访问特点,分别将三个方法定义为对同一个属性：获取、修改、删除,看下面的代码:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lyshark</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"get 函数运行了我..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @get.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,value)</span>:</span></span><br><span class="line">        print(<span class="string">"set 设置参数运行了我,传递的参数是: %s"</span>%value)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @get.deleter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"工作结束了,可以删除数据了"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># =========================================================</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp = lyshark()                    <span class="comment">#实例化</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp.get                            <span class="comment">#调用get属性,则会执行get()函数</span></span><br><span class="line">get 函数运行了我...</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp.get = <span class="string">'hello'</span>                  <span class="comment">#设置属性则会执行get.setter函数</span></span><br><span class="line">set 设置参数运行了我,传递的参数是: hello</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> temp.get                        <span class="comment">#删除工作,则会走get.deleter函数</span></span><br><span class="line">工作结束了,可以删除数据了</span><br></pre></td></tr></table></figure></p>
<p>下面来看一个具体例子,我们可以直接调用<code>obj.price</code>来获取商品价格,也可以通过赋值语句修改商品的价格等.<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Goods</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 原价</span></span><br><span class="line">        self.original_price = <span class="number">100</span></span><br><span class="line">        <span class="comment"># 折扣</span></span><br><span class="line">        self.discount = <span class="number">0.8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">price</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 实际价格 = 原价 * 折扣</span></span><br><span class="line">        new_price = self.original_price * self.discount</span><br><span class="line">        <span class="keyword">return</span> new_price</span><br><span class="line"></span><br><span class="line"><span class="meta">    @price.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">price</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.original_price = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @price.deltter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">price</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">del</span> self.original_price</span><br><span class="line"></span><br><span class="line"><span class="comment"># =========================================================</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Goods()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.price         <span class="comment"># 获取商品价格</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.price = <span class="number">200</span>   <span class="comment"># 修改商品原价</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> obj.price     <span class="comment"># 删除商品原价</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>

      
    </div>

    

<!--增加的底部版权代码-->
<div>
      
        
<div class="my_post_copyright">
  <p><span>本文标题:</span><a href="/2019/01/24/Python/Python-面向对象编程详解-8/">Python 面向对象编程详解(8)</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 王瑞 的个人博客">王瑞</a></p>
  <p><span>发布时间:</span>2019年01月24日 - 20:01</p>
  <p><span>最后更新:</span>2019年01月29日 - 14:01</p>
  <p><span>原始链接:</span><a href="/2019/01/24/Python/Python-面向对象编程详解-8/" title="Python 面向对象编程详解(8)">https://www.mkdirs.com/2019/01/24/Python/Python-面向对象编程详解-8/</a>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者</p>
</div>

      
</div>
    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Python/" rel="tag"> <i class="fa fa-tag"></i> Python</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/23/Python/Python-正则表达模块详解-7/" rel="next" title="Python 正则表达模块详解(7)">
                <i class="fa fa-chevron-left"></i> Python 正则表达模块详解(7)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/02/01/Python/Python-异常处理与反射机制-9/" rel="prev" title="Python 异常处理与反射机制(9)">
                Python 异常处理与反射机制(9) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="王瑞">
            
              <p class="site-author-name" itemprop="name">王瑞</p>
              <div class="site-description motion-element" itemprop="description">记录点滴技术成长之路</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">101</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://github.com/lyshark" title="GitHub &rarr; https://github.com/lyshark" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="mailto:1181506874@qq.com" title="E-Mail &rarr; mailto:1181506874@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://plus.google.com/lyshark" title="Google &rarr; https://plus.google.com/lyshark" rel="noopener" target="_blank"><i class="fa fa-fw fa-google"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://twitter.com/lyshark" title="Twitter &rarr; https://twitter.com/lyshark" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="http://wpa.qq.com/msgrd?v=3&uin=1181506874&site=hupaiyule&menu=yes" title="QQ &rarr; http://wpa.qq.com/msgrd?v=3&uin=1181506874&site=hupaiyule&menu=yes" rel="noopener" target="_blank"><i class="fa fa-fw fa-qq"></i></a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                  
                    
                  
                  <a href="https://weixin.qq.com" title="Wechat &rarr; https://weixin.qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-weixin"></i></a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象编程简介"><span class="nav-text">面向对象编程简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象—-gt-封装"><span class="nav-text">面向对象—&gt;封装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#◆实现简单的类封装◆"><span class="nav-text">◆实现简单的类封装◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆使用公有属性封装◆"><span class="nav-text">◆使用公有属性封装◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆使用私有属性封装◆"><span class="nav-text">◆使用私有属性封装◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆将类封装进对象中◆"><span class="nav-text">◆将类封装进对象中◆</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象—-gt-继承"><span class="nav-text">面向对象—&gt;继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#◆继承基类普通函数◆"><span class="nav-text">◆继承基类普通函数◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆继承基类构造函数◆"><span class="nav-text">◆继承基类构造函数◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆多类继承与多继承◆"><span class="nav-text">◆多类继承与多继承◆</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象—-gt-多态"><span class="nav-text">面向对象—&gt;多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象—-gt-包装"><span class="nav-text">面向对象—&gt;包装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#◆类的方法◆"><span class="nav-text">◆类的方法◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆静态方法◆"><span class="nav-text">◆静态方法◆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#◆属性方法◆"><span class="nav-text">◆属性方法◆</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">

<!-- 屏蔽版权开始 -->
&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王瑞</span>
<!-- 屏蔽版权结束 -->

  

  
</div>









        








        
      </div>
    </footer>

    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>




  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
